<!DOCTYPE html>
<html lang="zh-Hant">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="manifest" href="manifest.json">
    <title>Lucky 3 Solitaire</title>
    <style>
        :root {
            --bg-green: #0a3d1d;
            --card-w: 20vw;
            --card-h: 28vw;
            --max-w: 80px;
            --max-h: 115px;
            --gold: #ffd700;
            --fixed-gap: -20vw;
            --anim-scale: 1;
        }

        body {
            font-family: 'Arial Black', sans-serif;
            background: #051d0e;
            margin: 0;
            color: white;
            display: flex;
            flex-direction: column;
            height: 100vh;
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
            overflow: hidden;
            touch-action: manipulation;
        }

        #header {
            padding: 10px 10px;
            background: rgba(0, 0, 0, 0.62);
            border-bottom: 2px solid var(--gold);
        }

        .header-main {
            display: grid;
            grid-template-columns: auto 1fr auto auto;
            align-items: center;
            gap: 8px;
            min-height: 42px;
        }

        .header-stat {
            font-size: 11px;
            line-height: 1.2;
            min-width: 64px;
        }

        .header-title {
            color: var(--gold);
            letter-spacing: 1.6px;
            font-size: 1.02rem;
            font-weight: 900;
            text-align: center;
            line-height: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }

        .header-title-main {
            line-height: 1;
        }

        .header-mode-tag {
            display: none;
            font-size: 0.56rem;
            letter-spacing: 0.5px;
            color: #d3ecff;
            background: rgba(124, 190, 255, 0.22);
            border: 1px solid rgba(124, 190, 255, 0.55);
            border-radius: 999px;
            padding: 2px 6px;
            line-height: 1.1;
            white-space: nowrap;
        }

        .header-mode-tag.show {
            display: inline-block;
        }

        .header-controls {
            display: flex;
            align-items: center;
            justify-content: flex-end;
        }

        .timer-pill {
            font-size: 13px;
            font-weight: 700;
            font-variant-numeric: tabular-nums;
            padding: 7px 14px;
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 215, 0, 0.35);
            min-width: 84px;
            text-align: center;
        }

        .header-settings {
            font-size: 19px;
            line-height: 1;
            background: #263238;
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            font-weight: 700;
            min-height: 42px;
            min-width: 48px;
            touch-action: manipulation;
        }

        @media (max-width: 520px) {
            #header {
                padding: 9px 8px;
            }

            .header-stat {
                font-size: 13px;
                min-width: 72px;
            }

            .header-title {
                font-size: 1.03rem;
                letter-spacing: 1px;
            }

            .header-mode-tag {
                font-size: 0.54rem;
                padding: 2px 5px;
            }

            .timer-pill {
                font-size: 13px;
                min-width: 80px;
                padding: 7px 10px;
            }

            .header-settings {
                font-size: 20px;
                min-height: 42px;
                min-width: 42px;
                padding: 8px 10px;
            }
        }

        @media (orientation: landscape) and (max-height: 430px) {
            #header {
                padding: 6px 8px;
                gap: 6px;
            }

            .header-stat {
                font-size: 11px;
                min-width: 58px;
            }

            .header-title {
                font-size: 0.9rem;
                letter-spacing: 0.8px;
            }

            .header-mode-tag {
                font-size: 0.48rem;
                padding: 1px 5px;
            }

            .header-controls {
                gap: 0;
            }

            .timer-pill {
                font-size: 11px;
                min-width: 70px;
                padding: 5px 9px;
            }

            .header-settings {
                font-size: 17px;
                min-height: 36px;
                min-width: 38px;
                padding: 7px 8px;
            }
        }

        #board {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            gap: 8px;
            padding: 20px 5px;
            transition: all calc(0.6s * var(--anim-scale)) cubic-bezier(0.4, 0, 0.2, 1);
        }

        .column {
            display: flex;
            flex-direction: column;
            width: var(--card-w);
            max-width: var(--max-w);
            min-height: 120px;
            position: relative;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 6px;
        }

        .card {
            width: var(--card-w);
            height: var(--card-h);
            max-width: var(--max-w);
            max-height: var(--max-h);
            background: white;
            border-radius: 6px;
            color: black;
            position: relative;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.5);
            transition: transform calc(0.25s * var(--anim-scale)) cubic-bezier(0.18, 0.89, 0.32, 1.28);
            display: flex;
            flex-direction: column;
            padding: 6px;
            box-sizing: border-box;
            border: 1px solid #ccc;
            margin-bottom: var(--fixed-gap);
        }

        @media (min-width: 450px) {
            .card {
                margin-bottom: -85px;
            }
        }

        .card:last-child {
            margin-bottom: 0;
        }

        .card.red {
            color: #d32f2f;
        }

        .card.is-fading {
            opacity: 0 !important;
            visibility: hidden;
        }

        .card.selected {
            transform: translateX(40%) rotate(3deg);
            outline: 3px solid var(--gold);
            filter: brightness(1.1);
        }

        .card.invalid-flash {
            animation: invalid-shake calc(0.36s * var(--anim-scale)) ease-in-out 2;
            outline: 3px solid #ff3b30 !important;
            box-shadow: 0 0 0 2px rgba(255, 59, 48, 0.28), 0 0 16px rgba(255, 59, 48, 0.5);
        }

        @keyframes invalid-shake {

            0%,
            100% {
                transform: translateX(0);
            }

            25% {
                transform: translateX(-4px);
            }

            50% {
                transform: translateX(4px);
            }

            75% {
                transform: translateX(-3px);
            }
        }

        /* --- ç‰¹æ•ˆå±¤ --- */
        #fx-layer {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 9999;
        }

        .column-beam {
            position: absolute;
            width: 100%;
            height: 200vh;
            top: -50vh;
            background: linear-gradient(to right, transparent, rgba(255, 255, 255, 0.8), transparent);
            box-shadow: 0 0 30px white;
            animation: beam-out calc(0.8s * var(--anim-scale)) ease-out forwards;
        }

        @keyframes beam-out {
            0% {
                scaleX(0);
                opacity: 0;
            }

            20% {
                scaleX(1.5);
                opacity: 1;
            }

            100% {
                scaleX(0);
                opacity: 0;
            }
        }

        .column-clear-text {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
            font-size: 1rem;
            color: #fff;
            text-shadow: 0 0 10px var(--gold);
            background: rgba(0, 0, 0, 0.6);
            padding: 5px 10px;
            border-radius: 5px;
            animation: text-float-up calc(1.2s * var(--anim-scale)) ease-out forwards;
        }

        @keyframes text-float-up {
            0% {
                transform: translate(-50%, 0);
                opacity: 0;
            }

            20% {
                opacity: 1;
            }

            100% {
                transform: translate(-50%, -120px);
                opacity: 0;
            }
        }

        .combo-text {
            position: fixed;
            top: 45%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3.2rem;
            color: #fff;
            text-align: center;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.8), 0 0 20px rgba(255, 165, 0, 0.6);
            z-index: 10000;
            animation: combo-fancy calc(1.5s * var(--anim-scale)) cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
        }

        @keyframes combo-fancy {
            0% {
                scale: 0.5;
                opacity: 0;
            }

            15% {
                scale: 1.2;
                opacity: 1;
            }

            75% {
                opacity: 1;
            }

            100% {
                transform: translate(-50%, -100%);
                opacity: 0;
            }
        }

        .lucky-three-win {
            animation: win-glow 1s infinite alternate;
            z-index: 1000 !important;
        }

        @keyframes win-glow {
            from {
                transform: scale(1.2);
                box-shadow: 0 0 20px var(--gold);
            }

            to {
                transform: scale(1.4) rotate(10deg);
                box-shadow: 0 0 50px white, 0 0 100px var(--gold);
            }
        }

        .particle {
            position: absolute;
            width: 6px;
            height: 6px;
            background: var(--gold);
            animation: p-fly calc(0.8s * var(--anim-scale)) forwards;
        }

        @keyframes p-fly {
            0% {
                transform: translate(0, 0);
                opacity: 1;
            }

            100% {
                transform: translate(var(--tx), var(--ty));
                opacity: 0;
            }
        }

        /* Footer */
        #footer {
            background: rgba(0, 0, 0, 0.95);
            padding: 15px 10px calc(15px + env(safe-area-inset-bottom));
            display: flex;
            justify-content: space-around;
            align-items: center;
            border-top: 1px solid var(--gold);
        }

        .pile {
            width: 55px;
            height: 75px;
            border-radius: 5px;
            border: 1px solid white;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        #deck-pile {
            background: #1e88e5;
            box-shadow: 3px 3px 0 #0d47a1;
            cursor: pointer;
            font-size: 26px;
        }

        #discard-pile {
            background: rgba(255, 255, 255, 0.05);
            border: 1px dashed var(--gold);
        }

        .has-cards {
            background: white !important;
            color: black;
            border: 1px solid #999 !important;
        }

        .btn-main {
            background: #2e7d32;
            color: white;
            border: none;
            padding: 14px 28px;
            border-radius: 50px;
            font-weight: bold;
            box-shadow: 0 4px #000;
            cursor: pointer;
        }

        #btn-undo {
            background: #455a64;
            width: 50px;
            height: 50px;
            padding: 0;
            border-radius: 50%;
            box-shadow: 0 4px #263238;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #btn-undo svg {
            width: 24px;
            height: 24px;
            fill: white;
        }

        #btn-undo:disabled {
            opacity: 0.2;
            box-shadow: none;
            cursor: not-allowed;
        }

        .btn-main:active {
            transform: translateY(2px);
            box-shadow: 0 2px #1b5e20;
        }

        .flying {
            position: fixed;
            z-index: 9999;
            pointer-events: none;
            transition: all calc(0.5s * var(--anim-scale)) cubic-bezier(0.4, 0, 0.2, 1);
        }

        .card.face-down {
            background: linear-gradient(135deg, #0d47a1 0%, #1565c0 45%, #1e88e5 100%);
            border: 1px solid #e3f2fd;
            color: transparent;
            overflow: hidden;
        }

        .card.face-down::before {
            content: '';
            position: absolute;
            inset: 6px;
            border-radius: 4px;
            border: 2px solid rgba(255, 255, 255, 0.75);
            background:
                radial-gradient(circle at 25% 25%, rgba(255, 255, 255, 0.35) 0 2px, transparent 3px),
                radial-gradient(circle at 75% 75%, rgba(255, 255, 255, 0.35) 0 2px, transparent 3px),
                repeating-linear-gradient(45deg, rgba(255, 255, 255, 0.16) 0 6px, rgba(255, 255, 255, 0.05) 6px 12px);
        }

        .card.face-down::after {
            content: 'LUCKY 3';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.62rem;
            font-weight: 900;
            letter-spacing: 1px;
            color: rgba(255, 255, 255, 0.9);
        }

        .flying.mii-peek {
            animation: mii-peek-rise calc(0.28s * var(--anim-scale)) ease-out forwards, mii-peek-shake calc(0.58s * var(--anim-scale)) ease-in-out calc(0.3s * var(--anim-scale)) 2;
            filter: drop-shadow(0 0 14px rgba(255, 215, 0, 0.9));
        }

        .card.mii-land-pop {
            animation: mii-land-pop calc(0.42s * var(--anim-scale)) cubic-bezier(0.2, 0.9, 0.25, 1.2);
            transform-origin: 50% 85%;
        }

        @keyframes mii-land-pop {
            0% {
                transform: translateY(-8px) scale(1.08);
                filter: brightness(1.12);
            }

            55% {
                transform: translateY(2px) scale(0.97);
            }

            100% {
                transform: translateY(0) scale(1);
                filter: brightness(1);
            }
        }

        @keyframes mii-peek-rise {
            from {
                transform: translateY(0) scale(1);
            }

            to {
                transform: translateY(-12px) scale(1.07) rotate(-2deg);
            }
        }

        @keyframes mii-peek-shake {

            0%,
            100% {
                transform: translateY(-12px) scale(1.07) rotate(-2deg);
            }

            50% {
                transform: translateY(-9px) scale(1.11) rotate(2deg);
            }
        }

        .mii-text {
            position: absolute;
            top: -28px;
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
            font-size: 0.82rem;
            font-weight: 900;
            letter-spacing: 0.5px;
            color: #fff;
            background: rgba(16, 18, 20, 0.88);
            border: 1px solid rgba(255, 255, 255, 0.4);
            border-radius: 999px;
            padding: 4px 10px;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
            animation: mii-text-pop calc(1.4s * var(--anim-scale)) ease-out forwards;
            z-index: 1003;
        }

        @keyframes mii-text-pop {
            0% {
                transform: translate(-50%, 8px) scale(0.9);
                opacity: 0;
            }

            18% {
                transform: translate(-50%, 0) scale(1.05);
                opacity: 1;
            }

            70% {
                transform: translate(-50%, -2px) scale(1.02);
                opacity: 1;
            }

            100% {
                transform: translate(-50%, -14px) scale(1);
                opacity: 0;
            }
        }

        .big-msg {
            position: fixed;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            color: var(--gold);
            text-align: center;
            z-index: 10001;
        }

        .win-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.72);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10002;
            padding: 20px;
        }

        .win-panel {
            width: min(420px, 92vw);
            background: linear-gradient(180deg, #123a1f, #0a2414);
            border: 2px solid var(--gold);
            border-radius: 14px;
            box-shadow: 0 18px 40px rgba(0, 0, 0, 0.55);
            padding: 20px 18px;
            text-align: center;
        }

        .win-title {
            margin: 0;
            color: var(--gold);
            font-size: 1.8rem;
            letter-spacing: 1px;
        }

        .win-subtitle {
            margin: 8px 0 14px;
            font-size: 0.95rem;
            opacity: 0.9;
        }

        .win-stats {
            text-align: left;
            background: rgba(255, 255, 255, 0.07);
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 14px;
        }

        .win-stat-row {
            display: flex;
            justify-content: space-between;
            font-size: 1rem;
            padding: 6px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.14);
        }

        .win-stat-row:last-child {
            border-bottom: none;
        }

        .win-play-again {
            width: 100%;
            border: none;
            border-radius: 12px;
            background: var(--gold);
            color: #1b1b1b;
            font-weight: 900;
            font-size: 1.05rem;
            padding: 12px 14px;
            cursor: pointer;
            min-height: 46px;
        }

        .win-best {
            margin: 0 0 12px;
            padding: 10px;
            border-radius: 10px;
            font-size: 0.95rem;
            background: rgba(255, 215, 0, 0.18);
            border: 1px solid rgba(255, 215, 0, 0.45);
            color: #fff8cc;
        }

        .win-fortune {
            margin: 0 0 12px;
            padding: 10px;
            border-radius: 10px;
            font-size: 0.93rem;
            line-height: 1.45;
            background: rgba(129, 199, 132, 0.18);
            border: 1px solid rgba(165, 214, 167, 0.65);
            color: #e8ffe8;
        }

        .void-win-panel {
            width: min(430px, 92vw);
            background: radial-gradient(circle at top, #1f2a56 0%, #0d1433 55%, #070c21 100%);
            border: 2px solid #8ec7ff;
            border-radius: 16px;
            box-shadow: 0 20px 42px rgba(0, 0, 0, 0.6);
            padding: 20px 18px;
            text-align: center;
        }

        .void-win-title {
            margin: 0;
            color: #9dd3ff;
            font-size: 1.76rem;
            letter-spacing: 1px;
        }

        .void-win-subtitle {
            margin: 8px 0 14px;
            font-size: 0.95rem;
            line-height: 1.4;
            color: #d7ecff;
        }

        .void-win-badge {
            margin: 0 0 12px;
            padding: 10px;
            border-radius: 10px;
            border: 1px solid rgba(142, 199, 255, 0.7);
            background: rgba(142, 199, 255, 0.18);
            color: #eaf6ff;
            font-weight: 800;
        }

        .deadlock-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.78);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10003;
            padding: 20px;
        }

        .deadlock-panel {
            width: min(430px, 92vw);
            background: linear-gradient(180deg, #3a1111, #240a0a);
            border: 2px solid #ff6b6b;
            border-radius: 14px;
            box-shadow: 0 18px 40px rgba(0, 0, 0, 0.55);
            padding: 18px;
            text-align: center;
        }

        .deadlock-title {
            margin: 0;
            color: #ffd2d2;
            font-size: 1.35rem;
            letter-spacing: 0.5px;
        }

        .deadlock-text {
            margin: 10px 0 14px;
            font-size: 0.96rem;
            line-height: 1.5;
            color: #ffe6e6;
        }

        .deadlock-actions {
            display: flex;
            gap: 10px;
        }

        .deadlock-btn {
            flex: 1;
            border: none;
            border-radius: 10px;
            min-height: 44px;
            font-weight: 800;
            cursor: pointer;
            font-size: 0.95rem;
        }

        .deadlock-btn.undo {
            background: #78909c;
            color: #102027;
        }

        .deadlock-btn.new {
            background: #ffd54f;
            color: #3e2723;
        }

        .deadlock-btn:disabled {
            opacity: 0.45;
            cursor: not-allowed;
        }

        .need-three-tip {
            position: fixed;
            left: 50%;
            bottom: calc(96px + env(safe-area-inset-bottom));
            transform: translateX(-50%);
            background: rgba(20, 20, 20, 0.9);
            color: #fff9d0;
            border: 1px solid rgba(255, 215, 0, 0.55);
            border-radius: 999px;
            padding: 8px 14px;
            font-size: 0.9rem;
            font-weight: 800;
            z-index: 10004;
            animation: need-three-fade calc(1s * var(--anim-scale)) ease-out forwards;
            pointer-events: none;
        }

        .need-three-tip.rule-hint {
            max-width: min(360px, calc(100vw - 24px));
            white-space: pre-line;
            text-align: left;
            line-height: 1.45;
            border-color: rgba(255, 183, 77, 0.9);
            color: #fff6dd;
        }

        .settings-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.72);
            z-index: 10005;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 18px;
        }

        .settings-overlay.show {
            display: flex;
        }

        .settings-panel {
            width: min(430px, 92vw);
            background: linear-gradient(180deg, #143021, #0d2217);
            border: 2px solid var(--gold);
            border-radius: 14px;
            padding: 16px;
            box-shadow: 0 14px 36px rgba(0, 0, 0, 0.55);
        }

        .settings-title {
            margin: 0 0 12px;
            font-size: 1.2rem;
            color: var(--gold);
        }

        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
            padding: 10px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .setting-row:last-of-type {
            border-bottom: none;
        }

        .setting-label {
            font-size: 0.95rem;
            font-weight: 700;
        }

        .setting-value {
            font-size: 0.88rem;
            opacity: 0.8;
        }

        .setting-control {
            font-size: 0.92rem;
            padding: 6px 8px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.35);
            background: rgba(255, 255, 255, 0.08);
            color: #fff;
        }

        .setting-check {
            width: 20px;
            height: 20px;
            accent-color: #ffd54f;
        }

        .settings-close {
            margin-top: 14px;
            width: 100%;
            min-height: 44px;
            border: none;
            border-radius: 10px;
            background: #ffd54f;
            color: #1b1b1b;
            font-weight: 900;
            cursor: pointer;
        }

        .settings-achievement {
            margin-top: 10px;
            width: 100%;
            min-height: 42px;
            border: 1px solid rgba(255, 255, 255, 0.35);
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.08);
            color: #fff;
            font-weight: 800;
            cursor: pointer;
        }

        .settings-daily {
            margin-top: 10px;
            width: 100%;
            min-height: 42px;
            border: 1px solid rgba(147, 214, 255, 0.55);
            border-radius: 10px;
            background: rgba(42, 102, 166, 0.35);
            color: #d8eeff;
            font-weight: 900;
            cursor: pointer;
        }

        .win-daily {
            margin: 0 0 12px;
            padding: 9px 10px;
            border-radius: 10px;
            font-size: 0.9rem;
            line-height: 1.35;
            background: rgba(103, 58, 183, 0.2);
            border: 1px solid rgba(179, 136, 255, 0.55);
            color: #efe2ff;
        }

        .settings-restart {
            margin-top: 10px;
            width: 100%;
            min-height: 44px;
            border: none;
            border-radius: 10px;
            background: #c62828;
            color: #fff;
            font-weight: 900;
            cursor: pointer;
        }

        .settings-secondary {
            margin-top: 10px;
            width: 100%;
            min-height: 42px;
            border: 1px solid rgba(255, 255, 255, 0.35);
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.08);
            color: #fff;
            font-weight: 800;
            cursor: pointer;
        }

        .restart-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.72);
            z-index: 10006;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 18px;
        }

        .restart-overlay.show {
            display: flex;
        }

        .restart-panel {
            width: min(390px, 90vw);
            background: linear-gradient(180deg, #2e1111, #1c0909);
            border: 2px solid #ff6b6b;
            border-radius: 14px;
            padding: 16px;
            box-shadow: 0 14px 36px rgba(0, 0, 0, 0.55);
            text-align: center;
        }

        .restart-title {
            margin: 0;
            color: #ffd4d4;
            font-size: 1.12rem;
        }

        .restart-text {
            margin: 10px 0 14px;
            color: #ffeaea;
            font-size: 0.94rem;
            line-height: 1.45;
        }

        .restart-actions {
            display: flex;
            gap: 10px;
        }

        .restart-btn {
            flex: 1;
            min-height: 42px;
            border: none;
            border-radius: 10px;
            font-weight: 900;
            cursor: pointer;
        }

        .restart-btn.cancel {
            background: #607d8b;
            color: #fff;
        }

        .restart-btn.confirm {
            background: #d32f2f;
            color: #fff;
        }

        .tutorial-overlay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: min(440px, calc(100vw - 22px));
            z-index: 10007;
            display: none;
            pointer-events: none;
        }

        .tutorial-overlay.show {
            display: block;
        }

        .tutorial-panel {
            pointer-events: auto;
            background: linear-gradient(180deg, rgba(12, 35, 25, 0.96), rgba(7, 21, 15, 0.97));
            border: 2px solid var(--gold);
            border-radius: 12px;
            box-shadow: 0 12px 28px rgba(0, 0, 0, 0.45);
            padding: 12px;
        }

        .tutorial-title {
            margin: 0;
            font-size: 1.02rem;
            color: #ffe066;
            letter-spacing: 0.3px;
        }

        .tutorial-body {
            margin: 8px 0 10px;
            font-size: 0.92rem;
            line-height: 1.45;
            color: #f6fff8;
        }

        .tutorial-status {
            margin: 0 0 10px;
            font-size: 0.85rem;
            color: #d8f5de;
            opacity: 0.92;
        }

        .tutorial-actions {
            display: flex;
            gap: 8px;
        }

        .tutorial-btn {
            flex: 1;
            min-height: 38px;
            border: none;
            border-radius: 9px;
            font-weight: 800;
            cursor: pointer;
            font-size: 0.9rem;
        }

        .tutorial-btn.primary {
            background: #ffd54f;
            color: #1f1f1f;
        }

        .tutorial-btn.secondary {
            background: #546e7a;
            color: #fff;
        }

        .achievement-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.78);
            z-index: 10008;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 18px;
        }

        .achievement-overlay.show {
            display: flex;
        }

        .achievement-panel {
            width: min(440px, 92vw);
            max-height: 78vh;
            overflow: auto;
            background: linear-gradient(180deg, #112c1d, #0a1f14);
            border: 2px solid #fdd835;
            border-radius: 14px;
            padding: 14px;
            box-shadow: 0 14px 36px rgba(0, 0, 0, 0.55);
        }

        .achievement-title {
            margin: 0 0 10px;
            color: #ffe066;
            font-size: 1.2rem;
        }

        .achievement-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 12px;
        }

        .achievement-stat {
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 8px;
        }

        .achievement-stat-label {
            font-size: 0.78rem;
            opacity: 0.9;
        }

        .achievement-stat-value {
            margin-top: 2px;
            font-size: 1.05rem;
            font-weight: 900;
        }

        .achievement-badges {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
            margin-bottom: 12px;
        }

        .achievement-badge {
            border-radius: 10px;
            padding: 9px 10px;
            border: 1px dashed rgba(255, 255, 255, 0.35);
            background: rgba(255, 255, 255, 0.06);
            font-size: 0.88rem;
        }

        .achievement-badge.unlocked {
            border-style: solid;
            border-color: rgba(255, 215, 64, 0.8);
            background: rgba(255, 215, 64, 0.18);
            color: #fff6c2;
        }

        .achievement-progress {
            margin-top: 7px;
            width: 100%;
            height: 7px;
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.18);
            overflow: hidden;
        }

        .achievement-progress-fill {
            height: 100%;
            border-radius: 999px;
            background: linear-gradient(90deg, #8bc34a, #ffeb3b);
            transition: width 260ms ease;
        }

        .achievement-toast-wrap {
            position: fixed;
            top: calc(env(safe-area-inset-top) + 12px);
            left: 50%;
            transform: translateX(-50%);
            z-index: 10020;
            width: min(420px, 92vw);
            pointer-events: none;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .achievement-toast {
            padding: 10px 12px;
            border-radius: 12px;
            background: rgba(20, 34, 20, 0.92);
            border: 1px solid rgba(255, 215, 64, 0.62);
            box-shadow: 0 10px 22px rgba(0, 0, 0, 0.45);
            animation: achievement-toast-in calc(2.6s * var(--anim-scale)) ease forwards;
        }

        .achievement-toast-title {
            font-size: 0.95rem;
            font-weight: 900;
            color: #ffe082;
        }

        .achievement-toast-body {
            margin-top: 3px;
            font-size: 0.82rem;
            color: #e9fce8;
        }

        .achievement-burst {
            position: fixed;
            left: 50%;
            top: 28%;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #ffd54f;
            pointer-events: none;
            z-index: 10019;
            transform: translate(-50%, -50%);
            animation: achievement-burst calc(0.8s * var(--anim-scale)) ease-out forwards;
        }

        @keyframes achievement-burst {
            0% {
                opacity: 0.95;
                transform: translate(-50%, -50%) scale(0.8);
            }

            100% {
                opacity: 0;
                transform: translate(calc(-50% + var(--tx)), calc(-50% + var(--ty))) scale(0.05);
            }
        }

        @keyframes achievement-toast-in {
            0% {
                opacity: 0;
                transform: translateY(-12px) scale(0.96);
            }

            10% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }

            85% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }

            100% {
                opacity: 0;
                transform: translateY(-10px) scale(0.98);
            }
        }

        .achievement-close {
            width: 100%;
            min-height: 42px;
            border: none;
            border-radius: 10px;
            background: #ffd54f;
            color: #1b1b1b;
            font-weight: 900;
            cursor: pointer;
        }

        .leaderboard-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.78);
            z-index: 10009;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 18px;
        }

        .leaderboard-overlay.show {
            display: flex;
        }

        .leaderboard-panel {
            width: min(460px, 94vw);
            max-height: 80vh;
            overflow: auto;
            background: linear-gradient(180deg, #0f2135, #0a1523);
            border: 2px solid #7ec8ff;
            border-radius: 14px;
            padding: 14px;
            box-shadow: 0 14px 36px rgba(0, 0, 0, 0.55);
        }

        .leaderboard-title {
            margin: 0 0 8px;
            color: #bfe6ff;
            font-size: 1.2rem;
        }

        .leaderboard-subtitle {
            margin: 0 0 10px;
            font-size: 0.86rem;
            color: #d7ebff;
            opacity: 0.92;
        }

        .leaderboard-list {
            display: grid;
            grid-template-columns: 1fr;
            gap: 6px;
            margin-bottom: 12px;
        }

        .leaderboard-row {
            display: grid;
            grid-template-columns: 48px 1fr auto auto;
            align-items: center;
            gap: 8px;
            border-radius: 10px;
            padding: 8px 10px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.18);
            font-size: 0.88rem;
        }

        .leaderboard-row.mine {
            border-color: rgba(255, 215, 64, 0.7);
            background: rgba(255, 215, 64, 0.17);
        }

        .leaderboard-rank {
            font-weight: 900;
            color: #ffe082;
        }

        .leaderboard-user {
            color: #fff;
            font-weight: 700;
        }

        .leaderboard-time {
            color: #b9f6ca;
            font-weight: 900;
            font-variant-numeric: tabular-nums;
        }

        .leaderboard-moves {
            color: #d4edff;
            font-weight: 700;
        }

        .leaderboard-empty {
            padding: 12px;
            border-radius: 10px;
            text-align: center;
            font-size: 0.9rem;
            background: rgba(255, 255, 255, 0.08);
            color: #e3f2fd;
        }

        .leaderboard-close {
            width: 100%;
            min-height: 42px;
            border: none;
            border-radius: 10px;
            background: #7ec8ff;
            color: #0a1b2d;
            font-weight: 900;
            cursor: pointer;
        }

        body.high-contrast {
            background: #021409;
            color: #fff;
        }

        body.high-contrast .column {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.28);
        }

        body.high-contrast .card {
            border-width: 2px;
            border-color: #111;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.65);
        }

        body.high-contrast .card.selected {
            outline-color: #ffec3d;
            filter: brightness(1.14);
        }

        @keyframes need-three-fade {
            0% {
                transform: translate(-50%, 10px);
                opacity: 0;
            }

            20% {
                transform: translate(-50%, 0);
                opacity: 1;
            }

            100% {
                transform: translate(-50%, -10px);
                opacity: 0;
            }
        }
    </style>
</head>

<body>

    <div id="header">
        <div class="header-main">
            <div class="header-stat">DECK: <b id="deck-num">40</b></div>
            <div class="header-title">
                <span class="header-title-main">LUCKY 3</span>
                <span id="header-mode-tag" class="header-mode-tag"></span>
            </div>
            <div id="timer" class="timer-pill">00:00</div>
            <div class="header-controls">
                <button type="button" class="header-settings" onclick="toggleSettings(true)" aria-label="è¨­å®š">âš™</button>
            </div>
        </div>
    </div>

    <div id="settings-overlay" class="settings-overlay" onclick="onSettingsOverlayClick(event)">
        <div class="settings-panel">
            <h3 class="settings-title">éŠæˆ²è¨­å®š</h3>
            <div class="setting-row">
                <div class="setting-label">éŸ³æ•ˆ</div>
                <input id="setting-sound" class="setting-check" type="checkbox">
            </div>
            <div class="setting-row">
                <div class="setting-label">éœ‡å‹•</div>
                <input id="setting-vibration" class="setting-check" type="checkbox">
            </div>
            <div class="setting-row">
                <div class="setting-label">å‹•ç•«é€Ÿåº¦</div>
                <select id="setting-animation-speed" class="setting-control">
                    <option value="slow">æ…¢</option>
                    <option value="normal">ä¸­</option>
                    <option value="fast">å¿«</option>
                </select>
            </div>
            <div class="setting-row">
                <div class="setting-label">é«˜å°æ¯”æ¨¡å¼</div>
                <input id="setting-high-contrast" class="setting-check" type="checkbox">
            </div>
            <div class="setting-row">
                <div class="setting-label">å’ªç‰ŒåŠŸèƒ½</div>
                <input id="setting-mii-peek" class="setting-check" type="checkbox">
            </div>
            <div class="setting-row">
                <div class="setting-label">å›æ”¶å‹•ç•«</div>
                <input id="setting-recycle-anim" class="setting-check" type="checkbox">
            </div>
            <div class="setting-row">
                <div class="setting-label">ç‰ˆæœ¬è™Ÿ</div>
                <div id="setting-version" class="setting-value">v-</div>
            </div>
            <button type="button" class="settings-daily" onclick="startDailyChallenge()">æ¯æ—¥æŒ‘æˆ°</button>
            <button type="button" class="settings-achievement" onclick="openDailyLeaderboard()">ä»Šæ—¥æ’è¡Œæ¦œ</button>
            <button type="button" class="settings-achievement" onclick="openAchievementsFromSettings()">æˆå°±é é¢</button>
            <button type="button" class="settings-secondary" onclick="replayTutorial()">é‡æ’­æ•™å­¸</button>
            <button type="button" class="settings-restart" onclick="resetGameFromSettings()">é‡æ–°é–‹å±€</button>
            <button type="button" class="settings-close" onclick="toggleSettings(false)">é—œé–‰è¨­å®š</button>
        </div>
    </div>

    <div id="restart-overlay" class="restart-overlay" onclick="onRestartOverlayClick(event)">
        <div class="restart-panel">
            <h3 class="restart-title">ç¢ºå®šé‡æ–°é–‹å±€ï¼Ÿ</h3>
            <p class="restart-text">ç›®å‰ç‰Œå±€é€²åº¦æœƒè¢«æ¸…ç©ºï¼Œæ˜¯å¦è¦é–‹å§‹æ–°çš„ä¸€å±€ï¼Ÿ</p>
            <div class="restart-actions">
                <button type="button" class="restart-btn cancel" onclick="closeRestartConfirm()">å–æ¶ˆ</button>
                <button type="button" class="restart-btn confirm" onclick="confirmRestartGame()">é‡æ–°é–‹å±€</button>
            </div>
        </div>
    </div>

    <div id="tutorial-overlay" class="tutorial-overlay">
        <div class="tutorial-panel">
            <h3 id="tutorial-title" class="tutorial-title"></h3>
            <p id="tutorial-body" class="tutorial-body"></p>
            <p id="tutorial-status" class="tutorial-status"></p>
            <div class="tutorial-actions">
                <button id="tutorial-primary" type="button" class="tutorial-btn primary"></button>
                <button id="tutorial-secondary" type="button" class="tutorial-btn secondary"></button>
            </div>
        </div>
    </div>

    <div id="achievement-overlay" class="achievement-overlay" onclick="onAchievementOverlayClick(event)">
        <div class="achievement-panel">
            <h3 class="achievement-title">æˆå°±é é¢</h3>
            <div id="achievement-grid" class="achievement-grid"></div>
            <div id="achievement-badges" class="achievement-badges"></div>
            <button type="button" class="achievement-close" onclick="closeAchievements()">é—œé–‰</button>
        </div>
    </div>
    <div id="leaderboard-overlay" class="leaderboard-overlay" onclick="onLeaderboardOverlayClick(event)">
        <div class="leaderboard-panel">
            <h3 class="leaderboard-title">ä»Šæ—¥æ’è¡Œæ¦œ</h3>
            <p id="leaderboard-subtitle" class="leaderboard-subtitle">è¼‰å…¥ä¸­...</p>
            <div id="leaderboard-list" class="leaderboard-list"></div>
            <button type="button" class="leaderboard-close" onclick="closeDailyLeaderboard()">é—œé–‰</button>
        </div>
    </div>
    <div id="achievement-toast-wrap" class="achievement-toast-wrap"></div>

    <div id="board"></div>
    <div id="fx-layer"></div>

    <div id="footer">
        <!-- ç™¼ç‰Œ -->
        <div style="display: flex; flex-direction: column; align-items: center;">
            <div class="pile" id="deck-pile" onclick="dealOneCard()">ğŸ‚ </div>
            <div style="font-size: 10px; color: var(--gold); margin-top: 5px;">DEAL</div>
        </div>

        <!-- ä¸­é–“æŒ‰éˆ• -->
        <div style="display: flex; align-items: center; gap: 15px;">
            <button id="btn-undo" class="btn-main" onclick="undo()" disabled aria-label="Undo">
                <svg viewBox="0 0 24 24">
                    <path
                        d="M12.5 8c-2.65 0-5.05 1-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8z" />
                </svg>
            </button>
            <button id="btn-clear" class="btn-main" onclick="attemptClear()">æ¶ˆä¸‰å¼µ / MATCH 3</button>
        </div>

        <!-- å›æ”¶ -->
        <div style="text-align: center;">
            <div class="pile" id="discard-pile"></div>
            <div style="font-size: 10px; color: var(--gold); margin-top: 5px;">RECYCLE</div>
        </div>
    </div>

    <script>
        if ('serviceWorker' in navigator) {
            let refreshing = false;
            navigator.serviceWorker.addEventListener('controllerchange', () => {
                if (refreshing) return;
                refreshing = true;
                window.location.reload();
            });

            navigator.serviceWorker.register('./sw.js').then((registration) => {
                const activateWaiting = () => {
                    if (registration.waiting) {
                        registration.waiting.postMessage({ type: 'SKIP_WAITING' });
                    }
                };

                activateWaiting();
                registration.update().catch(() => { });

                registration.addEventListener('updatefound', () => {
                    const newWorker = registration.installing;
                    if (!newWorker) return;

                    newWorker.addEventListener('statechange', () => {
                        if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                            activateWaiting();
                        }
                    });
                });

                setInterval(() => {
                    registration.update().catch(() => { });
                }, 60 * 1000);

                document.addEventListener('visibilitychange', () => {
                    if (!document.hidden) {
                        registration.update().catch(() => { });
                    }
                });

                window.addEventListener('focus', () => {
                    registration.update().catch(() => { });
                });
            }).catch(() => { });
        }

        const suits = ['â™ ', 'â™¥', 'â™¦', 'â™£'], ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10'];
        const APP_VERSION = '2026.02.06';
        const GAME_STATE_KEY = 'lucky3-current-game';
        const SETTINGS_KEY = 'lucky3-settings';
        const TUTORIAL_STATE_KEY = 'lucky3-tutorial-state-v1';
        const ACHIEVEMENTS_KEY = 'lucky3-achievements-v1';
        const DAILY_CHALLENGE_KEY = 'lucky3-daily-challenge-v1';
        const DEV_MODE_KEY = 'lucky3-dev-mode-v1';
        const TUTORIAL_FIXED_SEED = 6;
        const FORTUNE_POOL = {
            'â™ ': [
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šé»‘æ¡ƒ 3ã€‚åšæ±ºå®šæœƒç‰¹åˆ¥æœæ–·ï¼Œå·¥ä½œèˆ‡å­¸ç¿’å®¹æ˜“ä¸€æ¬¡åˆ°ä½ã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šé»‘æ¡ƒ 3ã€‚ä½ ä»Šå¤©çš„è¡Œå‹•åŠ›å¾ˆå¼·ï¼Œå¡é—œçš„äº‹æœ‰æ©Ÿæœƒå¿«é€Ÿçªç ´ã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šé»‘æ¡ƒ 3ã€‚ä»Šå¤©å¾ˆé©åˆè™•ç†æœ€é›£çš„é‚£ä»¶äº‹ï¼Œå®Œæˆç‡åé«˜ã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šé»‘æ¡ƒ 3ã€‚å°ˆæ³¨åŠ›ä¸Šå‡ï¼ŒçŸ­æ™‚é–“å…§å°±èƒ½æŠŠé‡é»åšå®Œã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šé»‘æ¡ƒ 3ã€‚ä½ ä»Šå¤©çš„åˆ¤æ–·å¾ˆæº–ï¼Œé©åˆæ‹æ¿å®šæ¡ˆã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šé»‘æ¡ƒ 3ã€‚å‹‡æ•¢å¾€å‰ä¸€æ­¥ï¼Œæœƒé‡åˆ°é—œéµè½‰æ©Ÿã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šé»‘æ¡ƒ 3ã€‚æ•ˆç‡é‹äº®èµ·ä¾†ï¼Œä»Šå¤©åšäº‹æœƒç‰¹åˆ¥ä¿è½ã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šé»‘æ¡ƒ 3ã€‚ä»Šå¤©é©åˆæ¸…å–®å¼æ¨é€²ï¼Œè¶Šåšè¶Šé †ã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šé»‘æ¡ƒ 3ã€‚æ€è·¯æ¸…æ™°ï¼Œè¤‡é›œå•é¡Œæœƒè¢«ä½ æ‹†å¾—å¾ˆæ¼‚äº®ã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šé»‘æ¡ƒ 3ã€‚ä»Šå¤©æ˜¯çªç ´æ—¥ï¼Œå…ˆåšæœ€é›£çš„åè€Œæœ€çœåŠ›ã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šé»‘æ¡ƒ 3ã€‚ä½ æœƒæ¯”é æœŸæ›´å¿«çœ‹åˆ°æˆæœï¼Œæ”¾å¿ƒè¡åˆºã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šé»‘æ¡ƒ 3ã€‚é©åˆé–‹å•Ÿæ–°è¨ˆç•«ï¼Œç¬¬ä¸€æ­¥å°±æœ‰å¥½æ‰‹æ„Ÿã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šé»‘æ¡ƒ 3ã€‚è‡¨å ´åæ‡‰ç‰¹åˆ¥å¥½ï¼Œä»Šå¤©å¾ˆæœ‰ä¸»å°æ¬Šã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šé»‘æ¡ƒ 3ã€‚ä»Šå¤©åšå–æ¨ç‰¹åˆ¥æº–ï¼Œæ™‚é–“æœƒè¢«ä½ ç”¨å¾—å¾ˆå¥½ã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šé»‘æ¡ƒ 3ã€‚ä½ ä»Šå¤©çš„ç¯€å¥å¾ˆç©©ï¼Œå®¹æ˜“é€£çºŒæ‹¿ä¸‹å°å‹åˆ©ã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šé»‘æ¡ƒ 3ã€‚ç›´è¦ºèˆ‡ç†æ€§åŒæ™‚åœ¨ç·šï¼Œåšä»€éº¼éƒ½æ›´æœ‰æŠŠæ¡ã€‚'
            ],
            'â™¥': [
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šç´…å¿ƒ 3ã€‚äººéš›é‹ä¸Šå‡ï¼Œé©åˆä¸»å‹•è¯çµ¡é‡è¦çš„äººï¼Œæœƒæœ‰å¥½å›æ‡‰ã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šç´…å¿ƒ 3ã€‚ä»Šå¤©ç‰¹åˆ¥æœ‰æº«æš–ç·£åˆ†ï¼Œåˆä½œèˆ‡æºé€šéƒ½æ›´é †ã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šç´…å¿ƒ 3ã€‚ä»Šå¤©èªªå‡ºçš„å–„æ„æœƒè¢«æ”¾å¤§ï¼Œå›é¥‹æœƒå¾ˆå¿«å‡ºç¾ã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šç´…å¿ƒ 3ã€‚é—œä¿‚é‹èµ°å¼·ï¼Œé©åˆä¿®å¾©å°èª¤æœƒã€æ‹‰è¿‘è·é›¢ã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šç´…å¿ƒ 3ã€‚ä½ ä»Šå¤©å¾ˆæœ‰æ„ŸæŸ“åŠ›ï¼Œå®¹æ˜“å¾—åˆ°æ”¯æŒã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šç´…å¿ƒ 3ã€‚ä»Šå¤©é©åˆè¡¨é”æ„Ÿè¬ï¼Œæœƒæ”¶ç©«è¶…ä¹é æœŸçš„å–„æ„ã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šç´…å¿ƒ 3ã€‚æƒ…ç·’éŸŒæ€§é«˜ï¼Œä»Šå¤©èƒ½æŠŠå¿ƒæƒ…ç…§é¡§å¾—å¾ˆå¥½ã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šç´…å¿ƒ 3ã€‚æºé€šé‹ä½³ï¼Œé›£èŠçš„è©±é¡Œä¹Ÿèƒ½æŸ”é †è½åœ°ã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šç´…å¿ƒ 3ã€‚ä»Šå¤©å®¹æ˜“é‡åˆ°é¡˜æ„å¹«ä½ ä¸€æŠŠçš„äººã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šç´…å¿ƒ 3ã€‚çœŸèª æœƒæˆç‚ºä½ çš„å¹¸é‹é‘°åŒ™ã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šç´…å¿ƒ 3ã€‚ä»Šå¤©é©åˆåˆä½œï¼Œå½¼æ­¤åŠ æˆæ„Ÿç‰¹åˆ¥æ˜é¡¯ã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šç´…å¿ƒ 3ã€‚æŠŠå¿ƒè£¡æƒ³èªªçš„èªªå‡ºå£ï¼Œæœƒæœ‰æº«æš–å›éŸ³ã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šç´…å¿ƒ 3ã€‚ä»Šå¤©çš„ä½ å¾ˆæœ‰è¦ªå’ŒåŠ›ï¼Œé—œä¿‚è‡ªç„¶å‡æº«ã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šç´…å¿ƒ 3ã€‚æŸ”è»Ÿä½†ä¸é€€è®“ï¼Œä»Šå¤©æœƒæ˜¯å¾ˆæ¼‚äº®çš„å¹³è¡¡ã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šç´…å¿ƒ 3ã€‚ä½ ä»Šå¤©æ•£ç™¼å®‰å®šæ„Ÿï¼Œå®¹æ˜“æˆç‚ºåœ˜éšŠæ ¸å¿ƒã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šç´…å¿ƒ 3ã€‚é–‹æ”¾å¿ƒæ…‹æœƒå¸¶ä¾†ä¸€å€‹è®“ä½ å¿ƒæƒ…å¾ˆå¥½çš„æ¶ˆæ¯ã€‚'
            ],
            'â™¦': [
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šæ–¹å¡Š 3ã€‚è²¡é‹èˆ‡æ©Ÿæœƒé‹åå¼·ï¼Œå°æ©Ÿæœƒå¯èƒ½å¸¶ä¾†å¤§æ”¶ç©«ã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šæ–¹å¡Š 3ã€‚ä»Šå¤©é©åˆè«‡è³‡æºèˆ‡æ•ˆç‡ï¼Œå®¹æ˜“æ‹¿åˆ°è¶…å€¼çµæœã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šæ–¹å¡Š 3ã€‚ä»Šå¤©å°åƒ¹æ ¼èˆ‡åƒ¹å€¼çš„åˆ¤æ–·ç‰¹åˆ¥æº–ã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šæ–¹å¡Š 3ã€‚å°å°å˜—è©¦æœƒå¸¶ä¾†å¯¦éš›å›å ±ï¼Œå€¼å¾—ä¸»å‹•å‡ºæ“Šã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šæ–¹å¡Š 3ã€‚ä»Šå¤©é©åˆæ•´ç†è²¡å‹™èˆ‡è¨ˆç•«ï¼Œæœƒè¶Šç†è¶Šæ¸…æ¥šã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šæ–¹å¡Š 3ã€‚ä½ ä»Šå¤©å¾ˆå®¹æ˜“æŠ“åˆ°é«˜ CP çš„é¸æ“‡ã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šæ–¹å¡Š 3ã€‚å¯¦ç”¨é‹å¾ˆå¼·ï¼Œæ‰‹é‚Šå·¥å…·èˆ‡è³‡æºéƒ½èƒ½æ´¾ä¸Šç”¨å ´ã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šæ–¹å¡Š 3ã€‚ä»Šå¤©æ˜¯ã€Œå°æŠ•å…¥å¤§å›å ±ã€çš„ä¸€å¤©ã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šæ–¹å¡Š 3ã€‚ä½ ä»Šå¤©æœƒé‡åˆ°æå‡æ•ˆç‡çš„é—œéµç·šç´¢ã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šæ–¹å¡Š 3ã€‚é©åˆæŠŠæƒ³æ³•è½åœ°ï¼Œæˆæœæœƒæ¯”é æœŸå¿«ã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šæ–¹å¡Š 3ã€‚ä»Šå¤©çš„é¸æ“‡é¡Œï¼Œä½ æ›´å®¹æ˜“é¸åˆ°å°çš„é‚£å€‹ã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šæ–¹å¡Š 3ã€‚æŠŠæ¡å°çª—å£ï¼Œå¯èƒ½æ›ä¾†é•·æœŸå¥½è™•ã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šæ–¹å¡Š 3ã€‚ä»Šå¤©é©åˆè«‡æ¢ä»¶ï¼Œä½ æœƒæ‹¿åˆ°æ¼‚äº®å¹³è¡¡é»ã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šæ–¹å¡Š 3ã€‚åè²¡æ˜¯è³‡è¨Šé‹ï¼Œä»Šå¤©å¤šçœ‹ä¸€çœ¼å°±æœ‰æ”¶ç©«ã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šæ–¹å¡Š 3ã€‚ä½ ä»Šå¤©çš„å‹™å¯¦åŠ›å¾ˆå¼·ï¼Œæˆæ•ˆçœ‹å¾—è¦‹ã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šæ–¹å¡Š 3ã€‚å¥½æ©Ÿæœƒæ­£åœ¨é è¿‘ï¼Œè¨˜å¾—ä¸»å‹•ä¼¸æ‰‹æ¥ä½ã€‚'
            ],
            'â™£': [
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šæ¢…èŠ± 3ã€‚ç©©å®šé‹å¾ˆå¼·ï¼Œæ‰‹ä¸Šçš„è¨ˆç•«å¯æœ›æ‰å¯¦æ¨é€²ã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šæ¢…èŠ± 3ã€‚ä»Šå¤©é©åˆæ‰“åŸºç¤ï¼ŒæŒçºŒåšå°±æœƒçœ‹åˆ°æ˜é¡¯æˆæœã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šæ¢…èŠ± 3ã€‚ç´¯ç©å‹ä»»å‹™ä»Šå¤©ç‰¹åˆ¥æœ‰æ„Ÿï¼Œè¶Šåšè¶Šé †ã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šæ¢…èŠ± 3ã€‚ä½ çš„è€å¿ƒä»Šå¤©å°±æ˜¯å¹¸é‹ï¼Œæ…¢æ…¢ä¾†åè€Œæœ€å¿«ã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šæ¢…èŠ± 3ã€‚ä»Šå¤©é©åˆæŠŠæµç¨‹å„ªåŒ–ï¼Œå¾ŒçºŒæœƒçœå¾ˆå¤šåŠ›ã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šæ¢…èŠ± 3ã€‚ç©©ç©©å‰é€²å°±æ˜¯ç‹é“ï¼Œæˆæœæ­£åœ¨å †é«˜ã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šæ¢…èŠ± 3ã€‚ä»Šå¤©æ˜¯ã€Œå°æ­¥å¿«è·‘ã€çš„å¥½æ—¥å­ã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šæ¢…èŠ± 3ã€‚ä½ ä»Šå¤©å¾ˆé©åˆæ”¶æ–‚èˆ‡æ•´ç†ï¼Œå“è³ªæœƒä¸Šå‡ã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šæ¢…èŠ± 3ã€‚æŠŠç¯€å¥å®ˆä½ï¼Œä»Šå¤©æœƒæ”¶ç©«ä¸€ç¨®è¸å¯¦çš„å¥½é‹ã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šæ¢…èŠ± 3ã€‚ç©©å®šæ¨é€²å¸¶ä¾†é©šå–œï¼Œæ™šä¸€é»æœƒçœ‹åˆ°å›å ±ã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šæ¢…èŠ± 3ã€‚ä»Šå¤©å¾ˆé©åˆå®Œæˆã€Œå·®æœ€å¾Œä¸€æ­¥ã€çš„ä»»å‹™ã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šæ¢…èŠ± 3ã€‚ä½ ä»Šå¤©çš„æŒçºŒåŠ›å¾ˆå¼·ï¼Œé©åˆåšé•·ç·šå¸ƒå±€ã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šæ¢…èŠ± 3ã€‚ä»Šå¤©æŠŠåŸºç¤æ‰“å¥½ï¼Œæ˜å¤©å°±èƒ½åŠ é€Ÿèµ·é£›ã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šæ¢…èŠ± 3ã€‚ä½ çš„ç¯€å¥æ„Ÿåœ¨ç·šï¼Œäº‹æƒ…æœƒä¸€ä»¶ä»¶åˆ°ä½ã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šæ¢…èŠ± 3ã€‚ä¿æŒç°¡å–®èˆ‡ä¸€è‡´ï¼Œä»Šå¤©æœƒéå¸¸æœ‰æ”¶ç©«ã€‚',
                'ä»Šæ—¥å¹¸é‹ç±¤ï¼šæ¢…èŠ± 3ã€‚ä»Šå¤©æ˜¯æˆé•·æ—¥ï¼Œç©©å®šå°±æ˜¯æœ€å¼·å¹¸é‹ã€‚'
            ]
        };
        const CURATED_SEED_POOL = [1275812221, 3628551120, 606367270, 358920669, 2222841817, 3225477087, 2309752016, 1985074770, 2638962401, 900850657, 1489335650, 4076029864, 2963994244, 794629283, 4279884281, 3258954461, 1771240158, 1894919495, 521086708, 2782039014, 3103428802, 3392711254, 1332886262, 3714236204, 3177904835, 3816031487, 537118263, 3039926409, 3248785025, 3500853666, 3549227574, 3290547141, 632934638, 4054290008, 2799357092, 191006918, 2628108291, 2836619439, 2948184827, 340908918, 1578466140, 3422660045, 475393373, 335798232, 3835870152, 639820472, 310650570, 3719258071, 2723095807, 743831607, 3883700367, 1188222126, 3518690609, 4229095241, 2060580215, 4284531114, 2666550879, 1885481017, 1343206682, 3650701993, 3080301307, 237238962, 2298089972, 746174303, 1956448023, 3185048254, 535508116, 3476812088, 1123530692, 1830496085, 122356629, 537603219, 1295598574, 811416733, 3182599008, 2692275842, 3150612214, 777380178, 246643334, 2304453054, 243560447, 3398861821, 2463091201, 3918325751, 2945638224, 3768812192, 2601608737, 2680887125, 1168420279, 1079443488, 571483870, 3724477284, 3722470167, 1318956648, 185819016, 1318434620, 729048970, 1866406274, 104883598, 2100298599, 1057445846, 2721020200, 582511943, 3775380289, 2286700691, 1974975538, 449712409, 2979315877, 3353091248, 73174809, 2065994195, 961262570, 3412765489, 2637731884, 2618237548, 4126256062, 3589989436, 4218417434, 1909207656, 573470754, 3573622821, 765315689, 138264, 828527347, 3764764949, 420924797, 1095279962, 2843393608, 4068734076, 3587158471, 2661360546, 116187944, 2310110939, 2943536795, 917822702, 1107830752, 4003058239, 1493186743, 3465745039, 250209977, 2258905932, 3574463900, 1472713236, 3382686860, 3210137420, 355813857, 2466240206, 152440342, 3383707503, 3566240226, 165076099, 822440256, 3646622931, 1758563550, 3811660693, 2412212038, 1192185399, 1774996017, 1076903018, 157725440, 3843061538, 1613912632, 3977964895, 1296604371, 3070601345, 285310790, 4015940880, 3418446873, 2225857344, 2356314865, 2860386724, 116163653, 3460097145, 3829649461, 1346821441, 2992844579, 1756049933, 2995992889, 4091971931, 178720115, 89769246, 3691269787, 1768394131, 2262031480, 88709886, 3120777740, 650552621, 1539881514, 2294599586, 1915959826, 3165468777, 905890879, 1687026991, 791806478, 2795903404, 374025147, 4246678281, 3622523887, 3174022583, 2413978261, 2195915075, 840538431, 452206718, 1189885347, 2957533728, 3488691630, 582701074, 3575940294, 94889631, 2447041345, 1755446439, 3359219923, 4082973161, 2789116229, 3957230458, 3527392733, 1662237272, 1401559423, 4196556835, 4165113582, 2999933172, 1500302693, 98114199, 793049271, 1228397762, 2919818451, 2292247505, 1491482069, 4292545801, 4256345825, 3115675057, 2145334491, 778750252, 2317906957, 1052146820, 1315706890, 2127720917, 439879130, 1524275791, 1306230188, 1329937328, 2220672707, 965616358, 761081592, 1371853679, 1015489705, 46395596, 3772676417, 904742107, 3741296483, 808484403, 2503936959, 3506444826, 3586160451, 3852601493, 2531426216, 1751842362, 4019817812, 320439872, 1351955299, 3113887499, 2115866871, 377916049, 2174697149, 2349444348, 2711933051, 1279351839, 2427818235, 2423322412, 2930832467, 2181268647, 1806007188, 3491453778, 4084667167, 1236528494, 3035252264, 3972727159, 2079584679, 2775123538, 250276000, 301640389, 3697289981, 3877909430, 3039337577, 1029063577, 2631797203, 3969420794, 3295703994, 3826790292, 2440054992, 2395616129, 881013244, 2965755569, 3125414043, 175452881, 58284230, 1511227328, 2432021188, 907823707, 2193124688, 2492575124, 411399889, 1856752440, 2715850728, 363416585, 2099172409, 3564156969, 8524583, 2965005628, 2107968929, 1046242690, 3932676771, 1973558279, 1604416378, 3999850492, 3071330864, 2522024141, 795331891, 263824065, 1816063039, 1492466557, 2568097658, 3643356466, 1263710813, 1850225233, 606018625, 3737356985, 3797882648, 2661558033, 2817930327, 2101257379, 3036269243, 3706544591, 1197132468, 4116045880, 2060304954, 2431286522, 2517019579, 3146824824, 2336599433, 4219719222, 1823838851, 2510835141, 159696437, 2246346404, 2901613209, 2133892898, 2603058028, 2555684085, 2428220935, 1596555508, 2042909103, 809742562, 4221676028, 149510793, 1394597511, 1796870720, 1797525198, 79876841, 2960501466, 3446822654, 2902260296, 692802120, 3224909274, 760613202, 2358338784, 1730605193, 3447641070, 2196085750, 1911258107, 3291147441, 2894037042, 2757674758, 2920721076, 799534635, 3317143074, 4050040101, 103374518, 861742038, 353265455, 1300788220, 2872512171, 995836382, 1945366542, 2939751060, 1751277404, 1541280261, 1332180342, 1908227664, 454505079, 3349300728, 95487217, 1343601362, 188686901, 1436064219, 3735475823, 2884486321, 3716510325, 1971858608, 3166561243, 1932526046, 1577150466, 2889927230, 42630455, 1252943197, 1851283530, 2296888344, 286767820, 852272055, 3192031041, 3592192302, 4219921978, 2060273772, 2847688254, 2680911264, 2617972555, 2372759226, 1956018057, 4222310359, 143518972, 1352121374, 907477557, 3523372172, 259077893, 575779811, 3493792276, 1444698799, 1292275517, 222475509, 1302555748, 3812583322, 25562078, 472973209, 6886262, 4134905291, 584754020, 3123411929, 3082313296, 1866540449, 72831180, 3209286020, 2328242300, 1440862020, 2172326995, 398817070, 3103528700, 901431373, 1056706665, 1689267148, 3050358853, 1584762744, 2310464975, 3392716324, 3745703020, 3044118942, 2068185586, 3426236892, 2206083367, 4148701005, 278551419, 648511422, 2406420848, 4218017986, 3121934108, 2746130459, 351451732, 747184402, 2206235878, 3626850058, 167051876, 3213395369, 2425767972, 2140873449, 3696526921, 2916257720, 1856539040, 3127126473, 3783529869, 3324796575, 496835177, 2117398678, 2644893965, 104699258, 3408211183, 1439323439, 574510006, 1650122141, 1449833095, 887096891, 3543406337, 1843195760, 1170670551, 1862526360, 534211284, 3346030168, 3040976280, 2694923734, 2114679649, 3538644373, 3712232662];
        const DEFAULT_SETTINGS = { sound: true, vibration: true, animationSpeed: 'normal', highContrast: false, miiPeek: true, recycleAnim: true };
        const DEFAULT_ACHIEVEMENTS = {
            wins: 0,
            zeroClearWins: 0,
            streakShield: 0,
            maxCombo: 0,
            bestMoves: null,
            bestTimeSec: null,
            currentStreak: 0,
            longestStreak: 0,
            lastWinDate: ''
        };
        let deck = [], slots = [], discardPile = [], clearedGroups = [];
        let selected = [], nextSlotIndex = 0, isBusy = false, historyStack = [], combo = 0, lastCleared = null, startTime = Date.now();
        let winInterval = null, moveCount = 0, maxCombo = 0, hasWon = false, deadlockShown = false;
        let settings = { ...DEFAULT_SETTINGS };
        let achievements = { ...DEFAULT_ACHIEVEMENTS };
        let audioCtx = null;
        let tutorial = { active: false, step: 0 };
        let tutorialDeckMode = false;
        let winCardSuit = '';
        let gameMode = 'normal';
        let currentSeed = null;
        let lastDailyRankText = '';
        let developerMode = false;
        let devTapCount = 0;
        let devTapTimer = null;

        function shuffleInPlace(arr) {
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        function mulberry32(seed) {
            let t = seed >>> 0;
            return function () {
                t += 0x6D2B79F5;
                let x = Math.imul(t ^ (t >>> 15), 1 | t);
                x ^= x + Math.imul(x ^ (x >>> 7), 61 | x);
                return ((x ^ (x >>> 14)) >>> 0) / 4294967296;
            };
        }

        function shuffleWithRng(arr, rng) {
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(rng() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        function pickCuratedSeed() {
            if (!Array.isArray(CURATED_SEED_POOL) || CURATED_SEED_POOL.length === 0) return null;
            const idx = Math.floor(Math.random() * CURATED_SEED_POOL.length);
            return CURATED_SEED_POOL[idx] >>> 0;
        }

        function dailySeedIndex(dateKey) {
            if (!dateKey) return 0;
            let hash = 2166136261 >>> 0;
            for (let i = 0; i < dateKey.length; i++) {
                hash ^= dateKey.charCodeAt(i);
                hash = Math.imul(hash, 16777619) >>> 0;
            }
            return hash;
        }

        function pickDailySeed(dateKey = toLocalDateKey()) {
            if (!Array.isArray(CURATED_SEED_POOL) || CURATED_SEED_POOL.length === 0) return null;
            const idx = dailySeedIndex(dateKey) % CURATED_SEED_POOL.length;
            return CURATED_SEED_POOL[idx] >>> 0;
        }

        function buildSeededDeck(seed) {
            const fullDeck = [];
            suits.forEach(s => ranks.forEach(r => {
                fullDeck.push({ rank: r, suit: s, val: r === 'A' ? 1 : parseInt(r), color: s === 'â™¥' || s === 'â™¦' ? 'red' : 'black' });
            }));
            const rng = mulberry32(seed >>> 0);
            return shuffleWithRng(fullDeck, rng);
        }

        function createCard(rank, suit) {
            return { rank, suit, val: rank === 'A' ? 1 : parseInt(rank, 10), color: suit === 'â™¥' || suit === 'â™¦' ? 'red' : 'black' };
        }

        function fortuneBySuit(suit) {
            const list = FORTUNE_POOL[suit] || ['ä»Šæ—¥å¹¸é‹ç±¤ï¼šLucky 3ã€‚ä»Šå¤©æœƒæœ‰ä¸€ä»¶å°å¥½äº‹æ‚„æ‚„ç™¼ç”Ÿã€‚'];
            return list[Math.floor(Math.random() * list.length)];
        }

        function cardId(rank, suit) {
            return `${rank}${suit}`;
        }

        function buildTutorialDeck() {
            const fixedBottom = createCard('3', 'â™£');
            // Sequence is designed for tutorial flow:
            // opening deals 11 cards -> columns become [3,3,3,2],
            // then first manual DEAL draws the 12th card to column 4 and forms 9.
            const openingPlan = [
                createCard('2', 'â™ '),   // col1 #1
                createCard('10', 'â™¦'),  // col2 #1
                createCard('5', 'â™£'),   // col3 #1
                createCard('A', 'â™ '),   // col4 #1
                createCard('8', 'â™¥'),   // col1 #2
                createCard('4', 'â™£'),   // col2 #2
                createCard('6', 'â™ '),   // col3 #2
                createCard('A', 'â™¦'),   // col4 #2
                createCard('7', 'â™¦'),   // col1 #3
                createCard('2', 'â™¥'),   // col2 #3
                createCard('4', 'â™ '),   // col3 #3
                createCard('7', 'â™£')    // first manual DEAL -> col4 #3 => 1+1+7=9
            ];

            const used = new Set(openingPlan.map((c) => cardId(c.rank, c.suit)));
            used.add(cardId(fixedBottom.rank, fixedBottom.suit));

            const remaining = [];
            suits.forEach((s) => ranks.forEach((r) => {
                const id = cardId(r, s);
                if (used.has(id)) return;
                remaining.push(createCard(r, s));
            }));
            // Tutorial deck uses a fixed seed so every tutorial run is reproducible.
            shuffleWithRng(remaining, mulberry32(TUTORIAL_FIXED_SEED));

            const topDeck = [...remaining, ...openingPlan.slice().reverse()];
            return [fixedBottom, ...topDeck];
        }

        function seedOpeningCards(cardsPerColumn = 3) {
            for (let round = 0; round < cardsPerColumn; round++) {
                for (let i = 0; i < slots.length; i++) {
                    if (deck.length === 0) return;
                    slots[i].cards.push(deck.pop());
                }
            }
        }

        function runOpeningDealAnimation(cardsPerColumn = 3, queueOverride = null) {
            const queue = Array.isArray(queueOverride) && queueOverride.length > 0
                ? [...queueOverride]
                : (() => {
                    const autoQueue = [];
                    for (let round = 0; round < cardsPerColumn; round++) {
                        for (let i = 0; i < slots.length; i++) {
                            autoQueue.push(slots[i].id);
                        }
                    }
                    return autoQueue;
                })();

            isBusy = true;
            selected = [];
            render();

            return new Promise((resolve) => {
                const step = (index) => {
                    if (index >= queue.length || deck.length === 0) {
                        isBusy = false;
                        resolve();
                        return;
                    }

                    const slotId = queue[index];
                    const slot = slots.find((s) => s.id === slotId);
                    if (!slot || !slot.active) {
                        step(index + 1);
                        return;
                    }

                    const card = deck.pop();
                    const deckRect = document.getElementById('deck-pile').getBoundingClientRect();
                    const colEl = document.getElementById(`col-${slotId}`);
                    const colRect = colEl.getBoundingClientRect();
                    const targetTop = getDealTargetTop(colEl, slot.cards.length);
                    const fly = createFly(card, deckRect);
                    const flyDuration = getDelay(360);
                    fly.style.willChange = 'transform';
                    fly.style.transform = 'translate(0, 0)';

                    playSound('deal');
                    const deltaX = colRect.left - deckRect.left;
                    const deltaY = targetTop - deckRect.top;
                    const motion = fly.animate(
                        [
                            { transform: 'translate(0, 0)' },
                            { transform: `translate(${deltaX}px, ${deltaY}px)` }
                        ],
                        {
                            duration: flyDuration,
                            easing: 'cubic-bezier(0.22, 0.61, 0.36, 1)',
                            fill: 'forwards'
                        }
                    );

                    motion.onfinish = () => {
                        slot.cards.push(card);
                        fly.remove();
                        render();
                        setTimeout(() => step(index + 1), getDelay(30));
                    };
                };

                step(0);
            });
        }

        function getAnimScale() {
            if (settings.animationSpeed === 'slow') return 1.35;
            if (settings.animationSpeed === 'fast') return 0.75;
            return 1;
        }

        function getDelay(ms) {
            return Math.max(40, Math.round(ms * getAnimScale()));
        }

        function loadSettings() {
            try {
                const raw = localStorage.getItem(SETTINGS_KEY);
                if (!raw) return { ...DEFAULT_SETTINGS };
                const parsed = JSON.parse(raw);
                return {
                    sound: parsed.sound !== false,
                    vibration: parsed.vibration !== false,
                    animationSpeed: ['slow', 'normal', 'fast'].includes(parsed.animationSpeed) ? parsed.animationSpeed : 'normal',
                    highContrast: Boolean(parsed.highContrast),
                    miiPeek: parsed.miiPeek !== false,
                    recycleAnim: parsed.recycleAnim !== false
                };
            } catch (_) {
                return { ...DEFAULT_SETTINGS };
            }
        }

        function loadDeveloperMode() {
            try {
                return localStorage.getItem(DEV_MODE_KEY) === '1';
            } catch (_) {
                return false;
            }
        }

        function saveDeveloperMode() {
            try {
                localStorage.setItem(DEV_MODE_KEY, developerMode ? '1' : '0');
            } catch (_) { }
        }

        function saveSettings() {
            try {
                localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
            } catch (_) { }
        }

        function applySettings() {
            document.documentElement.style.setProperty('--anim-scale', String(getAnimScale()));
            document.body.classList.toggle('high-contrast', settings.highContrast);

            const soundEl = document.getElementById('setting-sound');
            const vibrationEl = document.getElementById('setting-vibration');
            const speedEl = document.getElementById('setting-animation-speed');
            const contrastEl = document.getElementById('setting-high-contrast');
            const miiPeekEl = document.getElementById('setting-mii-peek');
            const recycleAnimEl = document.getElementById('setting-recycle-anim');
            const versionEl = document.getElementById('setting-version');
            if (soundEl) soundEl.checked = settings.sound;
            if (vibrationEl) vibrationEl.checked = settings.vibration;
            if (speedEl) speedEl.value = settings.animationSpeed;
            if (contrastEl) contrastEl.checked = settings.highContrast;
            if (miiPeekEl) miiPeekEl.checked = settings.miiPeek;
            if (recycleAnimEl) recycleAnimEl.checked = settings.recycleAnim;
            if (versionEl) versionEl.innerText = `v${APP_VERSION}`;
        }

        function updateSetting(key, value) {
            settings[key] = value;
            applySettings();
            saveSettings();
        }

        function toggleSettings(show) {
            const overlay = document.getElementById('settings-overlay');
            if (!overlay) return;
            overlay.classList.toggle('show', show);
        }

        function updateHeaderModeTag() {
            const tag = document.getElementById('header-mode-tag');
            if (!tag) return;
            if (gameMode === 'daily') {
                tag.innerText = `ä»Šæ—¥æŒ‘æˆ° ${toLocalDateKey()}`;
                tag.classList.add('show');
            } else {
                tag.innerText = '';
                tag.classList.remove('show');
            }
        }

        function onSettingsOverlayClick(event) {
            if (event.target && event.target.id === 'settings-overlay') {
                toggleSettings(false);
            }
        }

        function bindSettingsUI() {
            const soundEl = document.getElementById('setting-sound');
            const vibrationEl = document.getElementById('setting-vibration');
            const speedEl = document.getElementById('setting-animation-speed');
            const contrastEl = document.getElementById('setting-high-contrast');
            const miiPeekEl = document.getElementById('setting-mii-peek');
            const recycleAnimEl = document.getElementById('setting-recycle-anim');
            if (!soundEl || !vibrationEl || !speedEl || !contrastEl || !miiPeekEl || !recycleAnimEl) return;

            soundEl.addEventListener('change', (e) => updateSetting('sound', e.target.checked));
            vibrationEl.addEventListener('change', (e) => updateSetting('vibration', e.target.checked));
            speedEl.addEventListener('change', (e) => updateSetting('animationSpeed', e.target.value));
            contrastEl.addEventListener('change', (e) => updateSetting('highContrast', e.target.checked));
            miiPeekEl.addEventListener('change', (e) => updateSetting('miiPeek', e.target.checked));
            recycleAnimEl.addEventListener('change', (e) => updateSetting('recycleAnim', e.target.checked));

            const titleEl = document.querySelector('.settings-title');
            if (titleEl && !titleEl.dataset.devBound) {
                titleEl.dataset.devBound = '1';
                titleEl.addEventListener('click', () => {
                    devTapCount += 1;
                    if (devTapTimer) clearTimeout(devTapTimer);
                    devTapTimer = setTimeout(() => {
                        devTapCount = 0;
                    }, 1200);

                    if (devTapCount >= 7) {
                        devTapCount = 0;
                        developerMode = !developerMode;
                        saveDeveloperMode();
                        showAchievementToast(
                            developerMode ? 'ğŸ› ï¸ é–‹ç™¼è€…æ¨¡å¼å·²é–‹å•Ÿ' : 'ğŸ› ï¸ é–‹ç™¼è€…æ¨¡å¼å·²é—œé–‰',
                            developerMode ? 'DEAL å‰æœƒè‡ªå‹•å…ˆæ¶ˆä¸€çµ„åˆæ³•ç‰Œã€‚' : 'DEAL å°‡æ¢å¾©ä¸€èˆ¬æµç¨‹ã€‚'
                        );
                    }
                });
            }
        }

        function getTutorialState() {
            try {
                return localStorage.getItem(TUTORIAL_STATE_KEY) || 'unseen';
            } catch (_) {
                return 'unseen';
            }
        }

        function isTutorialDismissed() {
            const state = getTutorialState();
            return state === 'completed' || state === 'skipped';
        }

        function setTutorialState(state) {
            try {
                localStorage.setItem(TUTORIAL_STATE_KEY, state);
            } catch (_) { }
        }

        function toggleTutorial(show) {
            const overlay = document.getElementById('tutorial-overlay');
            if (!overlay) return;
            overlay.classList.toggle('show', show);
        }

        function startTutorial(force = false) {
            if (!force && isTutorialDismissed()) return;
            tutorial.active = true;
            tutorial.step = 0;
            renderTutorial();
            toggleTutorial(true);
        }

        function closeTutorial(state = null) {
            tutorial.active = false;
            if (state === 'completed' || state === 'skipped') setTutorialState(state);
            toggleTutorial(false);
        }

        function replayTutorial() {
            toggleSettings(false);
            tutorialDeckMode = true;
            init(true, { mode: 'normal' });
        }

        function startDailyChallenge() {
            toggleSettings(false);
            init(true, { mode: 'daily' });
        }

        function nextTutorialStep() {
            tutorial.step = Math.min(4, tutorial.step + 1);
            if (tutorial.step === 4) {
                setTutorialState('completed');
                playSound('hint');
            }
            renderTutorial();
        }

        function renderTutorial() {
            if (!tutorial.active) return;
            const title = document.getElementById('tutorial-title');
            const body = document.getElementById('tutorial-body');
            const status = document.getElementById('tutorial-status');
            const primary = document.getElementById('tutorial-primary');
            const secondary = document.getElementById('tutorial-secondary');
            if (!title || !body || !status || !primary || !secondary) return;

            if (tutorial.step === 0) {
                title.innerText = 'æ–°æ‰‹æ•™å­¸ï¼ˆç´„ 30 ç§’ï¼‰';
                body.innerText = 'ç›®æ¨™æ˜¯æŠŠç‰Œå±€ç©åˆ°æœ€å¾Œåªå‰©ä¸€å¼µã€Œ3ã€ã€‚æ¸…ç‰Œè¦å‰‡ï¼šåŒä¸€åˆ—é¸ 3 å¼µï¼Œä¸”ç¸½å’Œè¦æ˜¯ 9 / 19 / 29ã€‚';
                status.innerText = 'æº–å‚™å¥½å¾Œé–‹å§‹ï¼Œæ•™å­¸ä¸æœƒæ“‹ä½ä½ æ“ä½œã€‚';
                primary.innerText = 'é–‹å§‹æ•™å­¸';
                secondary.innerText = 'ç•¥é';
                primary.onclick = () => { tutorial.step = 1; renderTutorial(); };
                secondary.onclick = () => closeTutorial('skipped');
                primary.style.display = '';
                secondary.style.display = '';
                return;
            }

            if (tutorial.step === 1) {
                title.innerText = 'æ­¥é©Ÿ 1ï¼šå…ˆç™¼ä¸€å¼µç‰Œ';
                body.innerText = 'è«‹é»åº•éƒ¨å·¦å´ã€ŒDEALã€ç™¼ä¸€å¼µç‰Œï¼Œç†Ÿæ‚‰ç¯€å¥ã€‚';
                status.innerText = 'ç­‰å¾…ä½ é»æ“Š DEAL...';
                primary.style.display = 'none';
                secondary.style.display = '';
                secondary.innerText = 'ç•¥éæ•™å­¸';
                secondary.onclick = () => closeTutorial('skipped');
                return;
            }

            if (tutorial.step === 2) {
                title.innerText = 'æ­¥é©Ÿ 2ï¼šé¸æ»¿ä¸‰å¼µ';
                body.innerText = 'åœ¨åŒä¸€åˆ—é¸ 3 å¼µï¼Œåˆæ³•ä½ç½®åªæœ‰ä¸‰ç¨®ï¼šâ‘  å°¾ä¸‰å¼µï¼ˆå‰ä¸‰å¼µï¼‰â‘¡ é ­1å°¾2 â‘¢ é ­2å°¾1ã€‚';
                status.innerText = 'ç­‰å¾…ä½ ç”¨ä¸Šè¿°å…¶ä¸­ä¸€ç¨®ä½ç½®é¸æ»¿ 3 å¼µ...';
                primary.style.display = 'none';
                secondary.style.display = '';
                secondary.innerText = 'ç•¥éæ•™å­¸';
                secondary.onclick = () => closeTutorial('skipped');
                return;
            }

            if (tutorial.step === 3) {
                title.innerText = 'æ­¥é©Ÿ 3ï¼šå˜—è©¦æ¶ˆä¸‰å¼µ';
                body.innerText = 'æŒ‰ä¸‹ã€Œæ¶ˆä¸‰å¼µ / MATCH 3ã€ã€‚åªè¦ç¸½å’Œæ˜¯ 9 / 19 / 29ï¼Œä¸”ä½ç½®ç¬¦åˆã€Œå°¾ä¸‰å¼µ / é ­1å°¾2 / é ­2å°¾1ã€å°±èƒ½æ¶ˆé™¤ã€‚';
                status.innerText = 'ç­‰å¾…ä½ æŒ‰ä¸‹ MATCH 3...';
                primary.style.display = 'none';
                secondary.style.display = '';
                secondary.innerText = 'ç•¥éæ•™å­¸';
                secondary.onclick = () => closeTutorial('skipped');
                return;
            }

            title.innerText = 'å®Œæˆï¼ä½ å·²æœƒåŸºæœ¬ç©æ³•';
            body.innerText = 'æ¥ä¸‹ä¾†ç›®æ¨™æ˜¯ç”¨æœ€å°‘æ­¥æ•¸å®Œæˆç‰Œå±€ã€‚ä¹‹å¾Œå¯åœ¨è¨­å®šä¸­ã€Œé‡æ’­æ•™å­¸ã€ã€‚';
            status.innerText = 'ç¥ä½ é€£æ“Šé †åˆ©ï¼Œæ‹¿ä¸‹ Lucky 3ï¼';
            primary.style.display = '';
            secondary.style.display = 'none';
            primary.innerText = 'å®Œæˆ';
            primary.onclick = () => closeTutorial('completed');
        }

        function onTutorialEvent(eventName) {
            if (!tutorial.active) return;
            if (tutorial.step === 1 && eventName === 'deal') {
                nextTutorialStep();
                return;
            }
            if (tutorial.step === 2 && eventName === 'selected_three') {
                nextTutorialStep();
                return;
            }
            if (tutorial.step === 3 && eventName === 'attempt_clear_success') {
                nextTutorialStep();
            }
        }

        function isLegalSelectionPosition(cardsLen, selectedIndices) {
            if (cardsLen < 3 || selectedIndices.length !== 3) return false;
            const sorted = [...selectedIndices].sort((a, b) => a - b);
            const legal =
                JSON.stringify(sorted) === JSON.stringify([cardsLen - 3, cardsLen - 2, cardsLen - 1]) ||
                JSON.stringify(sorted) === JSON.stringify([0, cardsLen - 2, cardsLen - 1]) ||
                JSON.stringify(sorted) === JSON.stringify([0, 1, cardsLen - 1]);
            return legal;
        }

        function showTutorialRuleHint() {
            const old = document.getElementById('need-three-tip');
            if (old) old.remove();
            const msg = document.createElement('div');
            msg.id = 'need-three-tip';
            msg.className = 'need-three-tip rule-hint';
            msg.innerText = 'æ•™å­¸æç¤ºï¼šå¿…é ˆç¬¦åˆä»¥ä¸‹å…¶ä¸€\n1) å°¾ä¸‰å¼µï¼ˆå‰ä¸‰å¼µï¼‰\n2) é ­1å°¾2\n3) é ­2å°¾1';
            document.body.appendChild(msg);
            triggerHaptic([18, 24, 18]);
            playSound('hint');
            setTimeout(() => {
                if (msg.parentNode) msg.remove();
            }, getDelay(1300));
        }

        function playTone(freq = 440, durationMs = 80, volume = 0.04, startAt = 0) {
            const Ctx = window.AudioContext || window.webkitAudioContext;
            if (!Ctx) return;
            if (!audioCtx) audioCtx = new Ctx();
            if (audioCtx.state === 'suspended') audioCtx.resume().catch(() => { });

            const now = audioCtx.currentTime + startAt;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.frequency.value = freq;
            osc.type = 'triangle';
            gain.gain.setValueAtTime(0.0001, now);
            gain.gain.linearRampToValueAtTime(volume, now + 0.01);
            gain.gain.exponentialRampToValueAtTime(0.0001, now + durationMs / 1000);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start(now);
            osc.stop(now + durationMs / 1000 + 0.02);
        }

        function playSound(name) {
            if (!settings.sound) return;
            try {
                if (name === 'deal') playTone(430, 50, 0.03);
                else if (name === 'clear') { playTone(550, 70, 0.04); playTone(740, 80, 0.04, 0.06); }
                else if (name === 'error') playTone(210, 110, 0.045);
                else if (name === 'hint') playTone(360, 60, 0.025);
                else if (name === 'recycle') { playTone(300, 70, 0.03); playTone(420, 70, 0.03, 0.08); }
                else if (name === 'win') { playTone(520, 90, 0.05); playTone(780, 120, 0.05, 0.09); }
                else if (name === 'deadlock') playTone(250, 120, 0.04);
            } catch (_) { }
        }

        function toLocalDateKey(date = new Date()) {
            const y = date.getFullYear();
            const m = String(date.getMonth() + 1).padStart(2, '0');
            const d = String(date.getDate()).padStart(2, '0');
            return `${y}-${m}-${d}`;
        }

        function addDays(dateKey, deltaDays) {
            if (!dateKey) return '';
            const date = new Date(`${dateKey}T00:00:00`);
            date.setDate(date.getDate() + deltaDays);
            return toLocalDateKey(date);
        }

        function loadDailyChallengeState() {
            try {
                const raw = localStorage.getItem(DAILY_CHALLENGE_KEY);
                if (!raw) return { lastCompletedDate: '' };
                const parsed = JSON.parse(raw);
                return { lastCompletedDate: typeof parsed.lastCompletedDate === 'string' ? parsed.lastCompletedDate : '' };
            } catch (_) {
                return { lastCompletedDate: '' };
            }
        }

        function saveDailyChallengeState(state) {
            try {
                localStorage.setItem(DAILY_CHALLENGE_KEY, JSON.stringify(state));
            } catch (_) { }
        }

        function markDailyChallengeWin() {
            if (gameMode !== 'daily') return '';
            const today = toLocalDateKey();
            const state = loadDailyChallengeState();
            if (state.lastCompletedDate === today) {
                return `ğŸ“… ä»Šæ—¥æŒ‘æˆ°å·²å®Œæˆï¼ˆ${today}ï¼‰`;
            }
            state.lastCompletedDate = today;
            saveDailyChallengeState(state);
            return `âœ… ä»Šæ—¥æŒ‘æˆ°é¦–æ¬¡å®Œæˆï¼(${today})`;
        }

        async function submitDailyScoreIfNeeded(current, kind = 'lucky3') {
            if (gameMode !== 'daily') {
                lastDailyRankText = '';
                return '';
            }
            const bridge = window.lucky3Firebase;
            if (!bridge || !bridge.submitDailyScore) {
                lastDailyRankText = '';
                return '';
            }
            try {
                const result = await bridge.submitDailyScore({
                    dateKey: toLocalDateKey(),
                    bestTimeMs: current.elapsedSec * 1000,
                    moves: current.moveCount,
                    maxCombo: current.maxCombo,
                    resultKind: kind
                });

                if (result.status === 'created') {
                    lastDailyRankText = 'ğŸ“ˆ å·²ç™»éŒ„ä»Šæ—¥æ’è¡Œæ¦œï¼ˆé¦–æ¬¡ä¸Šæ¦œï¼‰';
                } else if (result.status === 'updated') {
                    lastDailyRankText = 'ğŸ“ˆ ä»Šæ—¥æ’è¡Œæ¦œæˆç¸¾å·²æ›´æ–°ï¼';
                } else if (result.status === 'skipped') {
                    lastDailyRankText = 'ğŸ“ˆ ä»Šæ—¥æ’è¡Œæ¦œç¶­æŒä½ çš„æœ€ä½³ç´€éŒ„';
                } else {
                    lastDailyRankText = '';
                }
                return lastDailyRankText;
            } catch (e) {
                console.error('submit daily score failed:', e);
                lastDailyRankText = 'âš ï¸ æ’è¡Œæ¦œæäº¤å¤±æ•—ï¼ˆç¨å¾Œå¯å†è©¦ï¼‰';
                return lastDailyRankText;
            }
        }

        function loadAchievements() {
            try {
                const raw = localStorage.getItem(ACHIEVEMENTS_KEY);
                if (!raw) return { ...DEFAULT_ACHIEVEMENTS };
                const parsed = JSON.parse(raw);
                return {
                    wins: Number.isInteger(parsed.wins) ? parsed.wins : 0,
                    zeroClearWins: Number.isInteger(parsed.zeroClearWins) ? parsed.zeroClearWins : 0,
                    streakShield: Number.isInteger(parsed.streakShield) ? parsed.streakShield : 0,
                    maxCombo: Number.isInteger(parsed.maxCombo) ? parsed.maxCombo : 0,
                    bestMoves: Number.isInteger(parsed.bestMoves) ? parsed.bestMoves : null,
                    bestTimeSec: Number.isInteger(parsed.bestTimeSec) ? parsed.bestTimeSec : null,
                    currentStreak: Number.isInteger(parsed.currentStreak) ? parsed.currentStreak : 0,
                    longestStreak: Number.isInteger(parsed.longestStreak) ? parsed.longestStreak : 0,
                    lastWinDate: typeof parsed.lastWinDate === 'string' ? parsed.lastWinDate : ''
                };
            } catch (_) {
                return { ...DEFAULT_ACHIEVEMENTS };
            }
        }

        function saveAchievements() {
            try {
                localStorage.setItem(ACHIEVEMENTS_KEY, JSON.stringify(achievements));
            } catch (_) { }
        }

        function getUnlockedBadgeTitles() {
            return achievementBadgeRows().filter((r) => r.ok).map((r) => r.title);
        }

        function spawnAchievementBurst() {
            const count = 14;
            for (let i = 0; i < count; i++) {
                const dot = document.createElement('div');
                dot.className = 'achievement-burst';
                dot.style.setProperty('--tx', `${(Math.random() - 0.5) * 240}px`);
                dot.style.setProperty('--ty', `${(Math.random() - 0.5) * 180}px`);
                document.body.appendChild(dot);
                setTimeout(() => dot.remove(), getDelay(900));
            }
        }

        function showAchievementToast(title, body) {
            const wrap = document.getElementById('achievement-toast-wrap');
            if (!wrap) return;
            const el = document.createElement('div');
            el.className = 'achievement-toast';
            el.innerHTML = `<div class="achievement-toast-title">${title}</div><div class="achievement-toast-body">${body}</div>`;
            wrap.appendChild(el);
            setTimeout(() => el.remove(), getDelay(2700));
        }

        function updateAchievementsOnWin(current, kind = 'lucky3') {
            const beforeUnlocked = new Set(getUnlockedBadgeTitles());
            let streakNotice = '';
            achievements.wins += 1;
            if (kind === 'zero-clear') achievements.zeroClearWins += 1;
            achievements.maxCombo = Math.max(achievements.maxCombo, current.maxCombo);
            achievements.bestMoves = achievements.bestMoves == null ? current.moveCount : Math.min(achievements.bestMoves, current.moveCount);
            achievements.bestTimeSec = achievements.bestTimeSec == null ? current.elapsedSec : Math.min(achievements.bestTimeSec, current.elapsedSec);

            const today = toLocalDateKey();
            if (achievements.lastWinDate !== today) {
                const yesterday = addDays(today, -1);
                const twoDaysAgo = addDays(today, -2);
                if (achievements.lastWinDate === yesterday) {
                    achievements.currentStreak += 1;
                } else if (achievements.streakShield > 0 && achievements.lastWinDate === twoDaysAgo) {
                    achievements.streakShield = Math.max(0, achievements.streakShield - 1);
                    achievements.currentStreak += 1;
                    streakNotice = 'ğŸ›¡ï¸ é€£å‹ä¿è­·ç”Ÿæ•ˆï¼šå·²å¹«ä½ çºŒä¸Šé€£å‹ï¼';
                    showAchievementToast('ğŸ›¡ï¸ é€£å‹ä¿è­·è§¸ç™¼', 'ä½ éŒ¯é 1 å¤©ï¼Œä½†é€£å‹å·²ä¿ä½ã€‚');
                } else {
                    achievements.currentStreak = 1;
                }
                achievements.longestStreak = Math.max(achievements.longestStreak, achievements.currentStreak);
                achievements.lastWinDate = today;
            }

            if (achievements.currentStreak >= 5 && achievements.streakShield < 1) {
                achievements.streakShield = 1;
                if (!streakNotice) streakNotice = 'ğŸ›¡ï¸ é€£å‹ä¿è­·å……èƒ½å®Œæˆï¼šå¯å®¹éŒ¯ 1 å¤©ã€‚';
                showAchievementToast('ğŸ›¡ï¸ é€£å‹ä¿è­·å·²å……èƒ½', 'é€£å‹ 5 å¤©é”æˆï¼Œå·²ç²å¾— 1 æ¬¡ä¿è­·ã€‚');
            }

            const afterUnlocked = new Set(getUnlockedBadgeTitles());
            const unlockedNow = [...afterUnlocked].filter((x) => !beforeUnlocked.has(x));
            if (unlockedNow.length > 0) {
                unlockedNow.forEach((title) => {
                    showAchievementToast(`ğŸ† æˆå°±è§£é–ï¼š${title}`, 'å¤ªå¼·äº†ï¼ç¹¼çºŒä¿æŒé€™å€‹ç¯€å¥ã€‚');
                });
                spawnAchievementBurst();
                playSound('hint');
            }

            saveAchievements();
            return { streakNotice };
        }

        function achievementBadgeRows() {
            const rows = [
                {
                    title: 'é€£æ“Šé«˜æ‰‹',
                    ok: achievements.maxCombo >= 5,
                    text: achievements.maxCombo >= 5 ? `å·²é”æˆï¼šæœ€é«˜é€£æ“Š ${achievements.maxCombo}` : `é€²åº¦ï¼šæœ€é«˜é€£æ“Š ${achievements.maxCombo} / 5`,
                    progress: Math.min(1, achievements.maxCombo / 5)
                },
                {
                    title: 'å¿«æ‰‹ç©å®¶',
                    ok: achievements.bestMoves != null && achievements.bestMoves <= 18,
                    text: achievements.bestMoves == null ? 'é€²åº¦ï¼šå°šæœªå®Œæˆç‰Œå±€' : `é€²åº¦ï¼šæœ€çŸ­ ${achievements.bestMoves} æ­¥ï¼ˆç›®æ¨™ 18ï¼‰`,
                    progress: achievements.bestMoves == null ? 0 : Math.min(1, 18 / achievements.bestMoves)
                },
                {
                    title: 'ç©©å®šé€£å‹',
                    ok: achievements.longestStreak >= 3,
                    text: `é€²åº¦ï¼šæœ€é•·é€£å‹ ${achievements.longestStreak} å¤©ï¼ˆç›®æ¨™ 3ï¼‰`,
                    progress: Math.min(1, achievements.longestStreak / 3)
                },
                {
                    title: 'è€ç·´ç©å®¶',
                    ok: achievements.wins >= 10,
                    text: `é€²åº¦ï¼šç´¯è¨ˆå‹åˆ© ${achievements.wins} / 10`,
                    progress: Math.min(1, achievements.wins / 10)
                },
                {
                    title: 'è™›ç©ºæ”¶æŸ',
                    ok: achievements.zeroClearWins >= 1,
                    text: achievements.zeroClearWins >= 1 ? `å·²é”æˆï¼šå…¨æ¸…é›¶ ${achievements.zeroClearWins} æ¬¡` : 'é€²åº¦ï¼šå®Œæˆ 1 æ¬¡å…¨æ¸…é›¶çµå±€',
                    progress: Math.min(1, achievements.zeroClearWins / 1)
                }
            ];
            return rows;
        }

        function renderAchievements() {
            const grid = document.getElementById('achievement-grid');
            const badges = document.getElementById('achievement-badges');
            if (!grid || !badges) return;

            grid.innerHTML = `
                <div class="achievement-stat"><div class="achievement-stat-label">ç´¯è¨ˆå‹åˆ©</div><div class="achievement-stat-value">${achievements.wins}</div></div>
                <div class="achievement-stat"><div class="achievement-stat-label">å…¨æ¸…é›¶å‹åˆ©</div><div class="achievement-stat-value">${achievements.zeroClearWins}</div></div>
                <div class="achievement-stat"><div class="achievement-stat-label">é€£å‹ä¿è­·</div><div class="achievement-stat-value">${achievements.streakShield > 0 ? 'å·²å……èƒ½' : 'æœªå……èƒ½'}</div></div>
                <div class="achievement-stat"><div class="achievement-stat-label">ç›®å‰é€£å‹</div><div class="achievement-stat-value">${achievements.currentStreak} å¤©</div></div>
                <div class="achievement-stat"><div class="achievement-stat-label">æœ€é•·é€£å‹</div><div class="achievement-stat-value">${achievements.longestStreak} å¤©</div></div>
                <div class="achievement-stat"><div class="achievement-stat-label">æœ€é«˜é€£æ“Š</div><div class="achievement-stat-value">${achievements.maxCombo}</div></div>
                <div class="achievement-stat"><div class="achievement-stat-label">æœ€çŸ­æ­¥æ•¸</div><div class="achievement-stat-value">${achievements.bestMoves == null ? '-' : achievements.bestMoves}</div></div>
                <div class="achievement-stat"><div class="achievement-stat-label">æœ€å¿«æ™‚é–“</div><div class="achievement-stat-value">${achievements.bestTimeSec == null ? '-' : formatTime(achievements.bestTimeSec)}</div></div>
            `;

            badges.innerHTML = achievementBadgeRows().map((b) => `
                <div class="achievement-badge ${b.ok ? 'unlocked' : ''}">
                    <strong>${b.ok ? 'âœ…' : 'â¬œ'} ${b.title}</strong><br>${b.text}
                    <div class="achievement-progress"><div class="achievement-progress-fill" style="width:${Math.max(0, Math.min(100, Math.round((b.progress || 0) * 100)))}%"></div></div>
                </div>
            `).join('');
        }

        function openAchievements() {
            renderAchievements();
            const overlay = document.getElementById('achievement-overlay');
            if (!overlay) return;
            overlay.classList.add('show');
        }

        function closeAchievements() {
            const overlay = document.getElementById('achievement-overlay');
            if (!overlay) return;
            overlay.classList.remove('show');
        }

        function onAchievementOverlayClick(event) {
            if (event.target && event.target.id === 'achievement-overlay') {
                closeAchievements();
            }
        }

        function openAchievementsFromSettings() {
            toggleSettings(false);
            openAchievements();
        }

        function renderDailyLeaderboard(rows, uid, dateKey) {
            const list = document.getElementById('leaderboard-list');
            const subtitle = document.getElementById('leaderboard-subtitle');
            if (!list || !subtitle) return;

            subtitle.innerText = `æ—¥æœŸï¼š${dateKey}ï¼ˆTop ${rows.length || 20}ï¼‰`;

            if (!rows || rows.length === 0) {
                list.innerHTML = '<div class="leaderboard-empty">ä»Šå¤©é‚„æ²’æœ‰äººä¸Šæ¦œï¼Œå¿«æˆç‚ºç¬¬ä¸€åï¼</div>';
                return;
            }

            let myRank = null;
            list.innerHTML = rows.map((row) => {
                const mine = uid && row.uid === uid;
                if (mine) myRank = row.rank;
                return `
                    <div class="leaderboard-row ${mine ? 'mine' : ''}">
                        <div class="leaderboard-rank">#${row.rank}</div>
                        <div class="leaderboard-user">${mine ? 'ä½ ' : row.name}</div>
                        <div class="leaderboard-time">${formatMs(row.bestTimeMs)}</div>
                        <div class="leaderboard-moves">${row.moves}æ­¥</div>
                    </div>
                `;
            }).join('');

            if (myRank) subtitle.innerText = `æ—¥æœŸï¼š${dateKey}ï½œä½ çš„æ’åï¼š#${myRank}`;
        }

        async function openDailyLeaderboard() {
            toggleSettings(false);
            const overlay = document.getElementById('leaderboard-overlay');
            const list = document.getElementById('leaderboard-list');
            const subtitle = document.getElementById('leaderboard-subtitle');
            if (!overlay || !list || !subtitle) return;

            overlay.classList.add('show');
            subtitle.innerText = 'è¼‰å…¥ä¸­...';
            list.innerHTML = '<div class="leaderboard-empty">æ­£åœ¨è®€å–æ’è¡Œæ¦œè³‡æ–™...</div>';

            const bridge = window.lucky3Firebase;
            if (!bridge || !bridge.loadDailyLeaderboard) {
                subtitle.innerText = 'Firebase å°šæœªå°±ç·’';
                list.innerHTML = '<div class="leaderboard-empty">å°šæœªé€£æ¥é›²ç«¯æœå‹™ï¼Œè«‹ç¨å¾Œé‡è©¦ã€‚</div>';
                return;
            }

            try {
                const dateKey = toLocalDateKey();
                const payload = await bridge.loadDailyLeaderboard(dateKey, 20);
                renderDailyLeaderboard(payload.rows, payload.uid, dateKey);
            } catch (e) {
                console.error('load leaderboard failed:', e);
                subtitle.innerText = 'è¼‰å…¥å¤±æ•—';
                list.innerHTML = '<div class="leaderboard-empty">æ’è¡Œæ¦œè®€å–å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦ã€‚</div>';
            }
        }

        function closeDailyLeaderboard() {
            const overlay = document.getElementById('leaderboard-overlay');
            if (!overlay) return;
            overlay.classList.remove('show');
        }

        function onLeaderboardOverlayClick(event) {
            if (event.target && event.target.id === 'leaderboard-overlay') closeDailyLeaderboard();
        }

        // --- åˆå§‹åŒ–èˆ‡é‡ç½® ---
        function init(forceNew = false, options = {}) {
            // å¼·åˆ¶è§£é–ç‹€æ…‹
            isBusy = false;
            const targetMode = options.mode === 'daily' ? 'daily' : 'normal';

            // æ¸…é™¤ UI
            const fxLayer = document.getElementById('fx-layer');
            if (fxLayer) fxLayer.innerHTML = '';
            const bigMsg = document.querySelector('.big-msg');
            if (bigMsg) bigMsg.remove();
            const winOverlay = document.getElementById('win-overlay');
            if (winOverlay) winOverlay.remove();
            const deadlockOverlay = document.getElementById('deadlock-overlay');
            if (deadlockOverlay) deadlockOverlay.remove();
            if (winInterval) clearInterval(winInterval);

            if (!forceNew && targetMode === 'normal' && loadGameState()) {
                document.getElementById('btn-undo').disabled = historyStack.length === 0;
                updateHeaderModeTag();
                render();
                updateDiscard();
                if (!hasWon) checkDeadlock();
                return;
            }

            // é‡ç½®è³‡æ–™
            deck = [];
            discardPile = [];
            clearedGroups = [];
            if (tutorialDeckMode) {
                deck = buildTutorialDeck();
                gameMode = 'normal';
                currentSeed = null;
            } else {
                gameMode = targetMode;
                const pickedSeed = gameMode === 'daily' ? pickDailySeed() : pickCuratedSeed();
                if (pickedSeed == null) {
                    const fullDeck = [];
                    suits.forEach(s => ranks.forEach(r => {
                        fullDeck.push({ rank: r, suit: s, val: r === 'A' ? 1 : parseInt(r), color: s === 'â™¥' || s === 'â™¦' ? 'red' : 'black' });
                    }));
                    shuffleInPlace(fullDeck);
                    deck = fullDeck;
                    currentSeed = null;
                } else {
                    deck = buildSeededDeck(pickedSeed);
                    currentSeed = pickedSeed;
                }
            }

            slots = [
                { id: 0, cards: [], active: true },
                { id: 1, cards: [], active: true },
                { id: 2, cards: [], active: true },
                { id: 3, cards: [], active: true }
            ];

            selected = [];
            nextSlotIndex = tutorialDeckMode ? 3 : 0;
            historyStack = [];
            combo = 0;
            lastCleared = null;
            startTime = Date.now();
            moveCount = 0;
            maxCombo = 0;
            hasWon = false;
            deadlockShown = false;
            winCardSuit = '';

            // é‡æ–°æ¸²æŸ“
            document.getElementById('btn-undo').disabled = true;
            updateHeaderModeTag();
            render();
            updateDiscard();
            const tutorialOpeningQueue = tutorialDeckMode ? [0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2] : null;
            runOpeningDealAnimation(3, tutorialOpeningQueue).then(() => {
                updateDiscard();
                saveGameState();
                if (!hasWon) checkDeadlock();
                if (tutorialDeckMode) {
                    startTutorial(true);
                    tutorialDeckMode = false;
                } else {
                    startTutorial(false);
                }
            });
        }

        function resetGame() {
            openRestartConfirm();
        }

        function resetGameFromSettings() {
            toggleSettings(false);
            resetGame();
        }

        function openRestartConfirm() {
            const overlay = document.getElementById('restart-overlay');
            if (!overlay) return;
            overlay.classList.add('show');
        }

        function closeRestartConfirm() {
            const overlay = document.getElementById('restart-overlay');
            if (!overlay) return;
            overlay.classList.remove('show');
        }

        function onRestartOverlayClick(event) {
            if (event.target && event.target.id === 'restart-overlay') {
                closeRestartConfirm();
            }
        }

        function confirmRestartGame() {
            closeRestartConfirm();
            init(true, { mode: gameMode });
        }

        // è¨ˆæ™‚å™¨ (åªéœ€åœ¨é é¢åŠ è¼‰æ™‚åŸ·è¡Œä¸€æ¬¡ setInterval)
        setInterval(() => {
            const sec = Math.floor((Date.now() - startTime) / 1000);
            const m = Math.floor(sec / 60).toString().padStart(2, '0');
            const s = (sec % 60).toString().padStart(2, '0');
            const timerEl = document.getElementById('timer');
            if (timerEl) timerEl.innerText = `${m}:${s}`;
        }, 1000);

        // --- æ ¸å¿ƒæ¸²æŸ“ ---
        function render() {
            const board = document.getElementById('board');
            board.innerHTML = ''; // å¾¹åº•æ¸…ç©ºç•¶å‰ DOM

            slots.filter(s => s.active).forEach(slot => {
                const col = document.createElement('div');
                col.className = 'column'; col.id = `col-${slot.id}`;
                slot.cards.forEach((card, idx) => {
                    const div = document.createElement('div');
                    const selObj = selected.find(s => s.slotId === slot.id && s.idx === idx);
                    div.className = `card ${card.color} ${selObj ? 'selected' : ''}`;
                    // Keep original stack order stable even when selected.
                    div.style.zIndex = idx;
                    div.innerHTML = `<div style="font-weight:bold">${card.rank}</div><div style="align-self:center; font-size:1.6rem">${card.suit}</div>`;
                    div.onclick = () => {
                        if (isBusy) return;
                        const sIdx = selected.findIndex(s => s.slotId === slot.id && s.idx === idx);
                        if (sIdx > -1) selected.splice(sIdx, 1);
                        else {
                            if (selected.length > 0 && selected[0].slotId !== slot.id) selected = [];
                            if (selected.length < 3) selected.push({ slotId: slot.id, idx });
                        }

                        if (tutorial.active && tutorial.step === 2 && selected.length === 3) {
                            const picked = selected.map(s => s.idx);
                            const legal = isLegalSelectionPosition(slot.cards.length, picked);
                            if (legal) {
                                onTutorialEvent('selected_three');
                            } else {
                                showTutorialRuleHint();
                                setTimeout(() => {
                                    selected = [];
                                    render();
                                }, getDelay(650));
                                render();
                                return;
                            }
                        }
                        render();
                    };
                    col.appendChild(div);
                });
                board.appendChild(col);
            });
            document.getElementById('deck-num').innerText = deck.length;
        }

        // --- ç‰¹æ•ˆé‚è¼¯ ---
        function showColumnClearFX(slotId) {
            const colEl = document.getElementById(`col-${slotId}`);
            if (!colEl) return;
            triggerHaptic([80, 50, 80]);
            const beam = document.createElement('div'); beam.className = 'column-beam';
            colEl.appendChild(beam);
            const text = document.createElement('div'); text.className = 'column-clear-text';
            text.innerText = 'COLUMN CLEAR!'; colEl.appendChild(text);
            const rect = colEl.getBoundingClientRect();
            for (let i = 0; i < 15; i++) spawnP(rect.left + rect.width / 2, rect.top + rect.height / 2);
            setTimeout(() => { if (beam.parentNode) beam.remove(); if (text.parentNode) text.remove(); }, getDelay(1200));
        }

        function showMiiFX(colEl) {
            if (!colEl) return;
            const existing = colEl.querySelector('.mii-text');
            if (existing) existing.remove();

            const text = document.createElement('div');
            text.className = 'mii-text';
            text.innerText = 'å’ªç‰Œä¸­...';
            colEl.appendChild(text);
            triggerHaptic([25, 30, 25]);

            setTimeout(() => {
                if (text.parentNode) text.remove();
            }, getDelay(900));
        }

        function getDealTargetTop(colEl, existingCount) {
            if (!colEl || existingCount <= 0) return colEl?.getBoundingClientRect().top ?? 0;

            const lastCardEl = colEl.children[existingCount - 1];
            if (!lastCardEl) return colEl.getBoundingClientRect().top;

            const lastRect = lastCardEl.getBoundingClientRect();
            let step = 0;

            const getConfiguredGapPx = () => {
                if (window.innerWidth >= 450) return -85;
                const raw = getComputedStyle(document.documentElement).getPropertyValue('--fixed-gap').trim();
                if (raw.endsWith('vw')) {
                    const val = parseFloat(raw);
                    if (Number.isFinite(val)) return (window.innerWidth * val) / 100;
                }
                if (raw.endsWith('px')) {
                    const val = parseFloat(raw);
                    if (Number.isFinite(val)) return val;
                }
                return 0;
            };

            if (existingCount >= 2) {
                const prevCardEl = colEl.children[existingCount - 2];
                if (prevCardEl) {
                    const prevRect = prevCardEl.getBoundingClientRect();
                    step = lastRect.top - prevRect.top;
                }
            }

            // existingCount===1 æ™‚ï¼Œå”¯ä¸€é‚£å¼µä»æ˜¯ :last-childï¼Œmargin-bottom æœƒæ˜¯ 0ï¼Œ
            // æœƒå°è‡´ç¬¬äºŒå¼µè½é»ç®—å¤ªä½ï¼›æ”¹ç”¨é…ç½®é–“è·è¨ˆç®—ï¼Œé¿å…ç¬¬äºŒå¼µå¡é “ã€‚
            if (!Number.isFinite(step) || step === 0 || existingCount === 1) {
                step = lastRect.height + getConfiguredGapPx();
            }

            return lastRect.top + step;
        }

        function popNewlyDealtCard(slotId) {
            const colEl = document.getElementById(`col-${slotId}`);
            if (!colEl || colEl.children.length === 0) return;
            const newest = colEl.children[colEl.children.length - 1];
            newest.classList.add('mii-land-pop');
            setTimeout(() => newest.classList.remove('mii-land-pop'), getDelay(460));
        }

        function getLegalClearIndices(cards) {
            const len = cards.length;
            if (len < 3) return [];

            const candidates = [
                [len - 3, len - 2, len - 1],
                [0, len - 2, len - 1],
                [0, 1, len - 1]
            ];
            const uniqueCandidates = [...new Set(candidates.map(c => JSON.stringify(c)))].map(x => JSON.parse(x));
            return uniqueCandidates.filter((indices) => {
                if (indices.some(i => i < 0 || i >= len)) return false;
                const sum = indices.reduce((acc, i) => acc + cards[i].val, 0);
                return [9, 19, 29].includes(sum);
            });
        }

        function findFirstLegalClearMove() {
            for (const slot of slots) {
                if (!slot.active) continue;
                const legal = getLegalClearIndices(slot.cards);
                if (legal.length === 0) continue;
                const indices = legal[0];
                const sum = indices.reduce((acc, i) => acc + slot.cards[i].val, 0);
                return { slotId: slot.id, indices: [...indices].sort((a, b) => a - b), sum };
            }
            return null;
        }

        function performClearMove(slotId, sortedIndices, sum) {
            const slot = slots.find(s => s.id === slotId);
            if (!slot) return Promise.resolve(false);

            const currentCards = [...slot.cards];
            if (sortedIndices.some(i => i < 0 || i >= currentCards.length)) return Promise.resolve(false);

            isBusy = true;
            const colEl = document.getElementById(`col-${slotId}`);
            if (colEl) {
                sortedIndices.forEach(idx => {
                    const cardEl = colEl.children[idx];
                    if (cardEl) cardEl.classList.add('is-fading');
                });
            }

            const clearedObjects = sortedIndices.map(idx => ({ idx: idx, data: { ...currentCards[idx] } }));
            historyStack.push({ type: 'clear', slotId, cards: clearedObjects, prevLast: lastCleared, comboBefore: combo });
            document.getElementById('btn-undo').disabled = false;
            const destRect = document.getElementById('discard-pile').getBoundingClientRect();
            lastCleared = currentCards[sortedIndices[sortedIndices.length - 1]];

            if (colEl) {
                sortedIndices.forEach(idx => {
                    const cardEl = colEl.children[idx];
                    if (!cardEl) return;
                    const fly = createFly(currentCards[idx], cardEl.getBoundingClientRect());
                    requestAnimationFrame(() => {
                        fly.style.left = destRect.left + 'px'; fly.style.top = destRect.top + 'px';
                        fly.style.transform = 'scale(0.5) rotate(20deg)'; fly.style.opacity = '0';
                    });
                    setTimeout(() => fly.remove(), getDelay(550));
                });
            }

            return new Promise((resolve) => {
                setTimeout(() => {
                    const recycled = sortedIndices.map(i => slot.cards[i]);
                    discardPile.push(...recycled);
                    clearedGroups.push([...recycled]);
                    sortedIndices.slice().sort((a, b) => b - a).forEach(i => slot.cards.splice(i, 1));
                    combo++;
                    selected = [];
                    maxCombo = Math.max(maxCombo, combo);
                    moveCount++;
                    playSound('clear');
                    let colCleared = false;
                    if (slot.cards.length === 0) {
                        colCleared = true;
                        showColumnClearFX(slotId);
                    }

                    setTimeout(() => {
                        if (colCleared) slot.active = false;
                        render();
                        updateDiscard();
                        showCombo(sum);
                        checkVictory();
                        isBusy = false;
                        if (!hasWon) checkDeadlock();
                        saveGameState();
                        resolve(true);
                    }, colCleared ? getDelay(800) : 0);

                    triggerHaptic(sum === 29 ? [60, 40, 60] : 40);
                    if (sum === 29) spawnP(window.innerWidth / 2, window.innerHeight / 2);
                }, getDelay(400));
            });
        }

        // --- ç™¼ç‰Œèˆ‡æ¶ˆé™¤ ---
        async function dealOneCard() {
            if (isBusy) return;

            if (developerMode && !tutorial.active) {
                const autoMove = findFirstLegalClearMove();
                if (autoMove) {
                    await performClearMove(autoMove.slotId, autoMove.indices, autoMove.sum);
                    if (hasWon || isBusy) return;
                }
            }

            // å¦‚æœç‰Œåº«ç©ºäº†ï¼Œä½†å›æ”¶å€æœ‰ç‰Œï¼Œå‰‡é€²è¡Œå›æ”¶
            if (deck.length === 0 && clearedGroups.length > 0) {
                recycleDeck();
                return;
            }

            if (deck.length === 0) {
                checkDeadlock();
                return;
            }

            // Dealæ™‚å–æ¶ˆé¸å–
            if (selected.length > 0) {
                selected = [];
                render();
            }

            const avail = slots.find((s, i) => slots[(nextSlotIndex + i) % 4].active);
            if (!avail) return;
            isBusy = true; combo = 0;
            const target = slots[(nextSlotIndex + slots.indexOf(avail)) % 4];
            const prevIdx = nextSlotIndex;
            nextSlotIndex = (slots.indexOf(target) + 1) % 4;

            historyStack.push({ type: 'deal', slotId: target.id, prevIdx });
            document.getElementById('btn-undo').disabled = false;
            moveCount++;
            playSound('deal');
            onTutorialEvent('deal');

            const card = deck.pop();
            const isMiiMoment = settings.miiPeek && target.cards.length === 2;
            const fly = createFly(card, document.getElementById('deck-pile').getBoundingClientRect(), { hidden: isMiiMoment });
            render();
            const colEl = document.getElementById(`col-${target.id}`);
            const rect = colEl.getBoundingClientRect();
            const targetTop = getDealTargetTop(colEl, target.cards.length);

            requestAnimationFrame(() => {
                fly.style.left = rect.left + 'px';
                fly.style.top = targetTop + 'px';
            });

            if (isMiiMoment) {
                setTimeout(() => {
                    revealFlyCard(fly, card);
                    fly.classList.add('mii-peek');
                    showMiiFX(colEl);
                }, getDelay(760));

                setTimeout(() => {
                    target.cards.push(card);
                    fly.remove();
                    render();
                    popNewlyDealtCard(target.id);
                    isBusy = false;
                    checkDeadlock();
                    saveGameState();
                }, getDelay(1720));
            } else {
                setTimeout(() => {
                    target.cards.push(card);
                    fly.remove();
                    render();
                    isBusy = false;
                    checkDeadlock();
                    saveGameState();
                }, getDelay(400));
            }
        }

        function recycleDeck() {
            if (isBusy || clearedGroups.length === 0) return;
            isBusy = true;
            playSound('recycle');
            // æŒ‰æ¶ˆé™¤çµ„é †åºå›æ”¶ï¼šç¬¬ä¸€çµ„æ¶ˆé™¤çš„ç‰Œå›åˆ°ç‰Œå †æœ€ä¸Šæ–¹ï¼ˆæœ€å…ˆè¢«æŠ½åˆ°ï¼‰
            const groupsInReturnOrder = [];
            for (let i = clearedGroups.length - 1; i >= 0; i--) {
                groupsInReturnOrder.push([...clearedGroups[i]]);
            }
            const rebuiltDeck = [];
            groupsInReturnOrder.forEach((group) => rebuiltDeck.push(...group));
            const applyRecycleResult = () => {
                deck = rebuiltDeck;
                discardPile = [];
                clearedGroups = [];
                lastCleared = null;

                render();
                updateDiscard();
                isBusy = false;
                checkDeadlock();
                saveGameState();
            };

            if (settings.recycleAnim) {
                animateRecycleReturn(groupsInReturnOrder).then(applyRecycleResult);
            } else {
                applyRecycleResult();
            }
        }

        function showNeedThreeHint(selectedCount) {
            const old = document.getElementById('need-three-tip');
            if (old) old.remove();

            const msg = document.createElement('div');
            msg.id = 'need-three-tip';
            msg.className = 'need-three-tip';
            msg.innerText = selectedCount === 2 ? 'é‚„å·® 1 å¼µï¼Œæ‰èƒ½æ¶ˆä¸‰å¼µ' : 'è«‹å…ˆé¸æ»¿ 3 å¼µç‰Œ';
            document.body.appendChild(msg);

            const clearBtn = document.getElementById('btn-clear');
            if (clearBtn) {
                clearBtn.style.background = '#ad1457';
                setTimeout(() => { clearBtn.style.background = ''; }, getDelay(220));
            }

            triggerHaptic([18, 24, 18]);
            playSound('hint');
            setTimeout(() => {
                if (msg.parentNode) msg.remove();
            }, getDelay(980));
        }

        async function attemptClear() {
            if (isBusy) return;
            if (selected.length !== 3) {
                showNeedThreeHint(selected.length);
                return;
            }
            const slotId = selected[0].slotId; const slot = slots.find(s => s.id === slotId);
            const currentCards = [...slot.cards]; const sum = selected.reduce((a, c) => a + currentCards[c.idx].val, 0);
            const sortedIndices = selected.map(s => s.idx).sort((a, b) => a - b);
            const len = currentCards.length;
            const isPos = JSON.stringify(sortedIndices) === JSON.stringify([len - 3, len - 2, len - 1]) ||
                JSON.stringify(sortedIndices) === JSON.stringify([0, len - 2, len - 1]) ||
                JSON.stringify(sortedIndices) === JSON.stringify([0, 1, len - 1]);

            if ([9, 19, 29].includes(sum) && isPos) {
                onTutorialEvent('attempt_clear_success');
                await performClearMove(slotId, sortedIndices, sum);
            } else {
                combo = 0; triggerHaptic(100);
                playSound('error');
                document.getElementById('btn-clear').style.background = '#c62828';
                setTimeout(() => document.getElementById('btn-clear').style.background = '', getDelay(300));

                const slotId = selected[0]?.slotId;
                const colEl = slotId != null ? document.getElementById(`col-${slotId}`) : null;
                selected.forEach(s => {
                    const cardEl = colEl?.children?.[s.idx];
                    if (cardEl) cardEl.classList.add('invalid-flash');
                });

                setTimeout(() => {
                    selected = [];
                    render();
                    checkDeadlock();
                    saveGameState();
                }, getDelay(760));
            }
        }

        function undo() {
            if (historyStack.length === 0 || isBusy) return;
            const last = historyStack.pop(); combo = last.comboBefore || 0;
            moveCount = Math.max(0, moveCount - 1);
            if (last.type === 'deal') {
                const s = slots.find(x => x.id === last.slotId); deck.push(s.cards.pop()); nextSlotIndex = last.prevIdx;
            } else {
                const s = slots.find(x => x.id === last.slotId); s.active = true;
                // å¾å›æ”¶å †ç§»é™¤æœ€å¾Œä¸‰å¼µç‰Œ
                discardPile.splice(-3);
                clearedGroups.pop();
                last.cards.sort((a, b) => a.idx - b.idx).forEach(c => s.cards.splice(c.idx, 0, c.data));
                lastCleared = last.prevLast;
            }
            selected = []; render(); updateDiscard();
            if (historyStack.length === 0) document.getElementById('btn-undo').disabled = true;
            checkDeadlock();
            saveGameState();
        }

        function checkVictory() {
            if (hasWon) return;
            const all = slots.flatMap(s => s.cards);
            if (all.length === 0) {
                hasWon = true;
                setTimeout(() => {
                    showZeroClearWinPanel();
                    winInterval = setInterval(() => spawnP(Math.random() * window.innerWidth, Math.random() * window.innerHeight), 300);
                }, getDelay(500));
                return;
            }

            if (all.length === 1 && all[0].val === 3) {
                winCardSuit = all[0].suit;
                hasWon = true;
                setTimeout(() => {
                    const card = document.querySelector('.card'); if (card) card.classList.add('lucky-three-win');
                    showWinPanel();
                    winInterval = setInterval(() => spawnP(Math.random() * window.innerWidth, Math.random() * window.innerHeight), 300);
                }, getDelay(500));
            }
        }

        function showCombo(s) {
            if (combo < 2) return;
            const layer = document.getElementById('fx-layer');
            const comboDiv = document.createElement('div'); comboDiv.className = 'combo-text';
            comboDiv.innerHTML = `${combo} COMBO!<br><span style="font-size:1.2rem;color:var(--gold)">+${s} PTS</span>`;
            layer.appendChild(comboDiv); setTimeout(() => comboDiv.remove(), getDelay(1500));
        }

        function triggerHaptic(ms) { if (settings.vibration && navigator.vibrate) navigator.vibrate(ms); }

        function spawnP(x, y) {
            for (let i = 0; i < 15; i++) {
                const p = document.createElement('div'); p.className = 'particle'; p.style.left = x + 'px'; p.style.top = y + 'px';
                p.style.setProperty('--tx', (Math.random() - 0.5) * 400 + 'px'); p.style.setProperty('--ty', (Math.random() - 0.5) * 400 + 'px');
                document.getElementById('fx-layer').appendChild(p); setTimeout(() => p.remove(), getDelay(800));
            }
        }

        function setFlyFace(f, data) {
            f.classList.remove('face-down');
            f.classList.toggle('red', data.color === 'red');
            f.innerHTML = `<div style="font-weight:bold">${data.rank}</div><div style="align-self:center; font-size:1.6rem">${data.suit}</div>`;
        }

        function revealFlyCard(f, data) {
            setFlyFace(f, data);
        }

        function createFly(data, rect, options = {}) {
            const f = document.createElement('div');
            f.className = 'card flying';
            if (options.hidden) {
                f.classList.add('face-down');
                f.innerHTML = '';
            } else {
                setFlyFace(f, data);
            }
            f.style.left = rect.left + 'px';
            f.style.top = rect.top + 'px';
            document.body.appendChild(f);
            return f;
        }

        function animateRecycleReturn(groupsInReturnOrder) {
            if (!Array.isArray(groupsInReturnOrder) || groupsInReturnOrder.length === 0) {
                return Promise.resolve();
            }

            const fromEl = document.getElementById('discard-pile');
            const toEl = document.getElementById('deck-pile');
            if (!fromEl || !toEl) return Promise.resolve();

            const fromRect = fromEl.getBoundingClientRect();
            const toRect = toEl.getBoundingClientRect();
            const groupDelay = getDelay(55);
            const settleDelay = getDelay(220);
            const flyLife = getDelay(380);

            return new Promise((resolve) => {
                let index = 0;
                const step = () => {
                    if (index >= groupsInReturnOrder.length) {
                        setTimeout(resolve, settleDelay);
                        return;
                    }

                    const group = groupsInReturnOrder[index] || [];
                    group.forEach((card, cardIndex) => {
                        const fly = createFly(card, fromRect, { hidden: true });
                        const offsetX = (cardIndex - 1) * 2;
                        const offsetY = (cardIndex - 1) * -2;
                        fly.style.opacity = '0.94';
                        requestAnimationFrame(() => {
                            fly.style.left = `${toRect.left + offsetX}px`;
                            fly.style.top = `${toRect.top + offsetY}px`;
                            fly.style.transform = 'scale(0.9)';
                            fly.style.opacity = '0.2';
                        });
                        setTimeout(() => fly.remove(), flyLife);
                    });

                    index += 1;
                    setTimeout(step, groupDelay);
                };
                step();
            });
        }

        function updateDiscard() {
            const p = document.getElementById('discard-pile');
            if (lastCleared) {
                p.innerHTML = `<div style="font-size:10px; position:absolute; top:2px; left:4px;">${lastCleared.rank}</div><div style="font-size:14px;">${lastCleared.suit}</div>`;
                p.className = `pile has-cards ${lastCleared.color}`;
                p.style.boxShadow = `3px 3px 0 rgba(255,215,0,0.4)`;
            } else { p.className = 'pile'; p.innerHTML = ''; p.style.boxShadow = 'none'; }
        }

        function formatTime(totalSec) {
            const m = Math.floor(totalSec / 60).toString().padStart(2, '0');
            const s = (totalSec % 60).toString().padStart(2, '0');
            return `${m}:${s}`;
        }

        function formatMs(ms) {
            const sec = Math.floor(ms / 1000);
            const cs = Math.floor((ms % 1000) / 10).toString().padStart(2, '0');
            return `${formatTime(sec)}.${cs}`;
        }

        function loadBestStats() {
            try {
                const raw = localStorage.getItem('lucky3-best-stats');
                if (!raw) return { fastestTimeSec: null, fewestMoves: null, highestCombo: 0 };
                const parsed = JSON.parse(raw);
                return {
                    fastestTimeSec: Number.isFinite(parsed.fastestTimeSec) ? parsed.fastestTimeSec : null,
                    fewestMoves: Number.isFinite(parsed.fewestMoves) ? parsed.fewestMoves : null,
                    highestCombo: Number.isFinite(parsed.highestCombo) ? parsed.highestCombo : 0
                };
            } catch (_) {
                return { fastestTimeSec: null, fewestMoves: null, highestCombo: 0 };
            }
        }

        function saveBestStats(stats) {
            try {
                localStorage.setItem('lucky3-best-stats', JSON.stringify(stats));
            } catch (_) { }
        }

        function updateBestStats(current) {
            const best = loadBestStats();
            const isNewFastest = best.fastestTimeSec == null || current.elapsedSec < best.fastestTimeSec;
            const isNewFewestMoves = best.fewestMoves == null || current.moveCount < best.fewestMoves;
            const isNewHighestCombo = current.maxCombo > (best.highestCombo || 0);

            const nextBest = {
                fastestTimeSec: isNewFastest ? current.elapsedSec : best.fastestTimeSec,
                fewestMoves: isNewFewestMoves ? current.moveCount : best.fewestMoves,
                highestCombo: isNewHighestCombo ? current.maxCombo : best.highestCombo
            };
            saveBestStats(nextBest);

            return {
                best: nextBest,
                flags: { isNewFastest, isNewFewestMoves, isNewHighestCombo }
            };
        }

        function buildBestMessage(result) {
            const flags = result.flags;
            if (flags.isNewFastest) return `ğŸ‰ æœ¬å±€æœ€ä½³æˆç¸¾ï¼šç ´è‡ªå·±æœ€å¿«æ™‚é–“ï¼ˆ${formatTime(result.best.fastestTimeSec)}ï¼‰`;
            if (flags.isNewFewestMoves) return `âœ¨ æœ¬å±€æœ€ä½³æˆç¸¾ï¼šåˆ·æ–°æœ€å°‘æ­¥æ•¸ï¼ˆ${result.best.fewestMoves} æ­¥ï¼‰`;
            if (flags.isNewHighestCombo) return `ğŸ”¥ æœ¬å±€æœ€ä½³æˆç¸¾ï¼šåˆ·æ–°æœ€é«˜é€£æ“Šï¼ˆ${result.best.highestCombo}ï¼‰`;
            return `æœ€ä½³ç´€éŒ„ï¼šæœ€å¿« ${formatTime(result.best.fastestTimeSec || 0)} / æœ€å°‘ ${result.best.fewestMoves || 0} æ­¥`;
        }

        async function showWinPanel() {
            const old = document.getElementById('win-overlay');
            if (old) old.remove();

            const elapsedSec = Math.floor((Date.now() - startTime) / 1000);
            const current = { elapsedSec, moveCount, maxCombo };
            const todayKey = toLocalDateKey();
            const isFirstWinToday = achievements.lastWinDate !== todayKey;
            const fortuneText = isFirstWinToday ? fortuneBySuit(winCardSuit) : '';
            const bestResult = updateBestStats(current);
            const achievementResult = updateAchievementsOnWin(current, 'lucky3');
            const bestMessage = buildBestMessage(bestResult);
            const dailyMsg = markDailyChallengeWin();
            const rankMsg = await submitDailyScoreIfNeeded(current, 'lucky3');
            playSound('win');
            const overlay = document.createElement('div');
            overlay.className = 'win-overlay';
            overlay.id = 'win-overlay';
            overlay.innerHTML = `
                <div class="win-panel">
                    <h2 class="win-title">LUCKY 3 JACKPOT</h2>
                    <p class="win-subtitle">è¶…è®šï¼ä½ æŠŠç‰Œå±€æ”¶ä¹¾æ·¨äº† âœ¨</p>
                    <div class="win-stats">
                        <div class="win-stat-row"><span>ç”¨æ™‚</span><strong>${formatTime(elapsedSec)}</strong></div>
                        <div class="win-stat-row"><span>ç¸½æ­¥æ•¸</span><strong>${moveCount}</strong></div>
                        <div class="win-stat-row"><span>æœ€é«˜é€£æ“Š</span><strong>${maxCombo}</strong></div>
                    </div>
                    ${fortuneText ? `<p class="win-fortune">${fortuneText}</p>` : ''}
                    ${dailyMsg ? `<p class="win-daily">${dailyMsg}</p>` : ''}
                    ${rankMsg ? `<p class="win-daily">${rankMsg}</p>` : ''}
                    ${achievementResult.streakNotice ? `<p class="win-daily">${achievementResult.streakNotice}</p>` : ''}
                    <p class="win-best">${bestMessage}</p>
                    <button type="button" class="win-play-again" onclick="playAgain()">å†ä¾†ä¸€å±€</button>
                </div>
            `;
            document.body.appendChild(overlay);
        }

        async function showZeroClearWinPanel() {
            const old = document.getElementById('win-overlay');
            if (old) old.remove();

            const elapsedSec = Math.floor((Date.now() - startTime) / 1000);
            const current = { elapsedSec, moveCount, maxCombo };
            const bestResult = updateBestStats(current);
            const achievementResult = updateAchievementsOnWin(current, 'zero-clear');
            const bestMessage = buildBestMessage(bestResult);
            const dailyMsg = markDailyChallengeWin();
            const rankMsg = await submitDailyScoreIfNeeded(current, 'zero-clear');
            playSound('win');
            const overlay = document.createElement('div');
            overlay.className = 'win-overlay';
            overlay.id = 'win-overlay';
            overlay.innerHTML = `
                <div class="void-win-panel">
                    <h2 class="void-win-title">VOID CLEAR</h2>
                    <p class="void-win-subtitle">ä½ å®Œæˆäº†ç¨€æœ‰çµå±€ï¼šå ´ä¸Š 0 å¼µç‰Œï¼<br>é€™æ˜¯ä¸€å ´è¶…é«˜é›£åº¦çš„å®Œç¾æ”¶æŸã€‚</p>
                    <p class="void-win-badge">ğŸ† è§£é–æˆå°±ï¼šè™›ç©ºæ”¶æŸ</p>
                    ${dailyMsg ? `<p class="win-daily">${dailyMsg}</p>` : ''}
                    ${rankMsg ? `<p class="win-daily">${rankMsg}</p>` : ''}
                    ${achievementResult.streakNotice ? `<p class="win-daily">${achievementResult.streakNotice}</p>` : ''}
                    <div class="win-stats">
                        <div class="win-stat-row"><span>ç”¨æ™‚</span><strong>${formatTime(elapsedSec)}</strong></div>
                        <div class="win-stat-row"><span>ç¸½æ­¥æ•¸</span><strong>${moveCount}</strong></div>
                        <div class="win-stat-row"><span>æœ€é«˜é€£æ“Š</span><strong>${maxCombo}</strong></div>
                    </div>
                    <p class="win-best">${bestMessage}</p>
                    <button type="button" class="win-play-again" onclick="playAgain()">å†ä¾†ä¸€å±€</button>
                </div>
            `;
            document.body.appendChild(overlay);
        }

        function playAgain() {
            init(true, { mode: gameMode });
        }

        function hasLegalClearInSlot(cards) {
            const len = cards.length;
            if (len < 3) return false;

            const candidates = [
                [len - 3, len - 2, len - 1],
                [0, len - 2, len - 1],
                [0, 1, len - 1]
            ];
            const uniqueCandidates = [...new Set(candidates.map(c => JSON.stringify(c)))].map(x => JSON.parse(x));

            return uniqueCandidates.some(indices => {
                if (indices.some(i => i < 0 || i >= len)) return false;
                const sum = indices.reduce((acc, i) => acc + cards[i].val, 0);
                return [9, 19, 29].includes(sum);
            });
        }

        function hasAnyLegalClear() {
            return slots.some(s => s.active && hasLegalClearInSlot(s.cards));
        }

        function hideDeadlockOverlay() {
            const overlay = document.getElementById('deadlock-overlay');
            if (overlay) overlay.remove();
            deadlockShown = false;
        }

        function showDeadlockOverlay() {
            if (deadlockShown) return;
            const old = document.getElementById('deadlock-overlay');
            if (old) old.remove();

            const canUndo = historyStack.length > 0;
            const overlay = document.createElement('div');
            overlay.className = 'deadlock-overlay';
            overlay.id = 'deadlock-overlay';
            overlay.innerHTML = `
                <div class="deadlock-panel">
                    <h3 class="deadlock-title">å¡ä½äº†ï¼ç›®å‰ç„¡åˆæ³•æ¶ˆé™¤</h3>
                    <p class="deadlock-text">ç‰Œåº«å·²ç©ºï¼Œä¸”å ´ä¸Šæ²’æœ‰å¯æ¶ˆé™¤çš„ 9 / 19 / 29 çµ„åˆã€‚ä½ æƒ³è¦å€’è½‰ä¸€æ­¥ï¼Œé‚„æ˜¯ç›´æ¥é–‹æ–°å±€ï¼Ÿ</p>
                    <div class="deadlock-actions">
                        <button type="button" class="deadlock-btn undo" onclick="resolveDeadlock('undo')" ${canUndo ? '' : 'disabled'}>å€’è½‰ä¸€æ­¥</button>
                        <button type="button" class="deadlock-btn new" onclick="resolveDeadlock('new')">é–‹æ–°å±€</button>
                    </div>
                </div>
            `;
            document.body.appendChild(overlay);
            deadlockShown = true;
            triggerHaptic([80, 50, 80]);
            playSound('deadlock');
        }

        function resolveDeadlock(action) {
            hideDeadlockOverlay();
            if (action === 'undo') {
                undo();
                return;
            }
            if (action === 'new') {
                init(true);
            }
        }

        function checkDeadlock() {
            if (hasWon || isBusy) return false;

            if (deck.length > 0 || clearedGroups.length > 0) {
                hideDeadlockOverlay();
                return false;
            }

            if (hasAnyLegalClear()) {
                hideDeadlockOverlay();
                return false;
            }

            showDeadlockOverlay();
            return true;
        }

        function buildSavePayload() {
            const elapsedSec = Math.floor((Date.now() - startTime) / 1000);
            return {
                deck,
                slots,
                discardPile,
                clearedGroups,
                nextSlotIndex,
                historyStack,
                combo,
                lastCleared,
                moveCount,
                maxCombo,
                hasWon,
                gameMode,
                currentSeed,
                elapsedSec
            };
        }

        function isValidCard(card) {
            return card && typeof card.rank === 'string' && typeof card.suit === 'string' && Number.isFinite(card.val) &&
                (card.color === 'red' || card.color === 'black');
        }

        function isValidSlot(slot) {
            return slot && Number.isInteger(slot.id) && Array.isArray(slot.cards) && typeof slot.active === 'boolean' &&
                slot.cards.every(isValidCard);
        }

        function saveGameState() {
            try {
                localStorage.setItem(GAME_STATE_KEY, JSON.stringify(buildSavePayload()));
            } catch (_) { }
        }

        function loadGameState() {
            try {
                const raw = localStorage.getItem(GAME_STATE_KEY);
                if (!raw) return false;
                const parsed = JSON.parse(raw);

                if (!Array.isArray(parsed.deck) || !Array.isArray(parsed.slots) || !Array.isArray(parsed.discardPile) || !Array.isArray(parsed.clearedGroups)) return false;
                if (!parsed.deck.every(isValidCard) || !parsed.discardPile.every(isValidCard)) return false;
                if (!parsed.slots.every(isValidSlot)) return false;
                if (!parsed.clearedGroups.every(group => Array.isArray(group) && group.every(isValidCard))) return false;

                deck = parsed.deck;
                slots = parsed.slots;
                discardPile = parsed.discardPile;
                clearedGroups = parsed.clearedGroups;
                nextSlotIndex = Number.isInteger(parsed.nextSlotIndex) ? parsed.nextSlotIndex : 0;
                historyStack = Array.isArray(parsed.historyStack) ? parsed.historyStack : [];
                combo = Number.isInteger(parsed.combo) ? parsed.combo : 0;
                lastCleared = parsed.lastCleared && isValidCard(parsed.lastCleared) ? parsed.lastCleared : null;
                moveCount = Number.isInteger(parsed.moveCount) ? parsed.moveCount : 0;
                maxCombo = Number.isInteger(parsed.maxCombo) ? parsed.maxCombo : 0;
                hasWon = Boolean(parsed.hasWon);
                gameMode = parsed.gameMode === 'daily' ? 'daily' : 'normal';
                currentSeed = Number.isInteger(parsed.currentSeed) ? parsed.currentSeed : null;
                deadlockShown = false;
                selected = [];
                const elapsedSec = Number.isFinite(parsed.elapsedSec) ? Math.max(0, parsed.elapsedSec) : 0;
                startTime = Date.now() - elapsedSec * 1000;
                updateHeaderModeTag();
                return true;
            } catch (_) {
                return false;
            }
        }

        window.addEventListener('beforeunload', saveGameState);
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) saveGameState();
        });

        developerMode = loadDeveloperMode();
        settings = loadSettings();
        achievements = loadAchievements();
        bindSettingsUI();
        applySettings();
        if (!isTutorialDismissed()) {
            tutorialDeckMode = true;
            init(true);
        } else {
            init();
        }
    </script>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-app.js";
        import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-auth.js";
        import {
            getFirestore,
            collection,
            doc,
            getDoc,
            getDocs,
            limit,
            orderBy,
            query,
            serverTimestamp,
            setDoc
        } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyCC5MVDctiEw_r4-bru2vaVozMjnzYx0KA",
            authDomain: "lucky3-d6bb3.firebaseapp.com",
            projectId: "lucky3-d6bb3",
            storageBucket: "lucky3-d6bb3.firebasestorage.app",
            messagingSenderId: "245595237917",
            appId: "1:245595237917:web:a2643aa43f846a558c60f4"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        const ready = (async () => {
            try {
                await signInAnonymously(auth);
            } catch (e) {
                console.error("Anonymous auth failed:", e);
            }
        })();

        function fallbackName(uid) {
            return `Player-${String(uid || '').slice(0, 6) || 'guest'}`;
        }

        async function submitDailyScore(payload) {
            await ready;
            const user = auth.currentUser;
            if (!user) throw new Error("auth user unavailable");

            const dateKey = payload.dateKey;
            const bestTimeMs = Number(payload.bestTimeMs);
            const moves = Number(payload.moves);
            const maxCombo = Number(payload.maxCombo);
            const resultKind = payload.resultKind === 'zero-clear' ? 'zero-clear' : 'lucky3';
            if (!dateKey || !Number.isFinite(bestTimeMs)) throw new Error("invalid payload");

            const ref = doc(db, 'daily_leaderboards', dateKey, 'entries', user.uid);
            const snap = await getDoc(ref);
            const nextData = {
                uid: user.uid,
                name: fallbackName(user.uid),
                bestTimeMs: Math.max(0, Math.round(bestTimeMs)),
                moves: Number.isFinite(moves) ? Math.max(0, Math.round(moves)) : 0,
                maxCombo: Number.isFinite(maxCombo) ? Math.max(0, Math.round(maxCombo)) : 0,
                resultKind,
                updatedAt: serverTimestamp()
            };

            if (!snap.exists()) {
                await setDoc(ref, nextData);
                return { status: 'created' };
            }

            const prev = snap.data() || {};
            const prevBest = Number(prev.bestTimeMs);
            if (Number.isFinite(prevBest) && nextData.bestTimeMs >= prevBest) {
                return { status: 'skipped' };
            }

            if (typeof prev.name === 'string' && prev.name.trim()) nextData.name = prev.name;
            await setDoc(ref, nextData, { merge: true });
            return { status: 'updated' };
        }

        async function loadDailyLeaderboard(dateKey, topN = 20) {
            await ready;
            const user = auth.currentUser;
            const col = collection(db, 'daily_leaderboards', dateKey, 'entries');
            const q = query(col, orderBy('bestTimeMs', 'asc'), limit(Math.max(1, Math.min(50, topN || 20))));
            const snap = await getDocs(q);
            const rows = [];
            snap.forEach((d, idx) => {
                const data = d.data() || {};
                rows.push({
                    rank: idx + 1,
                    uid: data.uid || d.id,
                    name: typeof data.name === 'string' && data.name ? data.name : fallbackName(data.uid || d.id),
                    bestTimeMs: Number.isFinite(data.bestTimeMs) ? data.bestTimeMs : 0,
                    moves: Number.isFinite(data.moves) ? data.moves : 0
                });
            });
            return {
                uid: user ? user.uid : '',
                rows
            };
        }

        window.firebaseApp = app;
        window.firebaseAuth = auth;
        window.firebaseDb = db;
        window.lucky3Firebase = {
            ready,
            submitDailyScore,
            loadDailyLeaderboard
        };
    </script>
</body>

</html>
