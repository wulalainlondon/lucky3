<!DOCTYPE html>
<html lang="zh-Hant">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="manifest" href="manifest.json">
    <title>Lucky 3 Solitaire</title>
    <style>
        :root {
            --bg-green: #0a3d1d;
            --card-w: 20vw;
            --card-h: 28vw;
            --max-w: 80px;
            --max-h: 115px;
            --gold: #ffd700;
            --fixed-gap: -5vw;
        }

        body {
            font-family: 'Arial Black', sans-serif;
            background: #051d0e;
            margin: 0;
            color: white;
            display: flex;
            flex-direction: column;
            height: 100vh;
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
            overflow: hidden;
            touch-action: manipulation;
        }

        #header {
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
            background: rgba(0, 0, 0, 0.6);
            border-bottom: 2px solid var(--gold);
        }

        .header-stat {
            font-size: 11px;
            line-height: 1.2;
            min-width: 64px;
        }

        .header-title {
            color: var(--gold);
            letter-spacing: 2px;
            font-size: 1rem;
            font-weight: 900;
            text-align: center;
            flex: 1;
        }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .timer-pill {
            font-size: 12px;
            font-weight: 700;
            font-variant-numeric: tabular-nums;
            padding: 6px 10px;
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 215, 0, 0.35);
            min-width: 56px;
            text-align: center;
        }

        .header-restart {
            font-size: 11px;
            background: #c62828;
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            font-weight: 700;
            min-height: 40px;
            min-width: 84px;
            touch-action: manipulation;
        }

        .header-restart:active {
            transform: translateY(1px);
        }

        @media (max-width: 520px) {
            #header {
                padding: 12px 12px;
            }

            .header-stat {
                font-size: 13px;
                min-width: 76px;
            }

            .header-title {
                font-size: 1.25rem;
                letter-spacing: 1.5px;
            }

            .timer-pill {
                font-size: 14px;
                min-width: 68px;
                padding: 8px 12px;
            }

            .header-restart {
                font-size: 13px;
                min-height: 44px;
                min-width: 92px;
                padding: 10px 14px;
            }
        }

        @media (orientation: landscape) and (max-height: 430px) {
            #header {
                padding: 6px 10px;
                gap: 8px;
            }

            .header-stat {
                font-size: 11px;
                min-width: 60px;
            }

            .header-title {
                font-size: 0.95rem;
                letter-spacing: 1px;
            }

            .header-controls {
                gap: 8px;
            }

            .timer-pill {
                font-size: 11px;
                min-width: 54px;
                padding: 5px 9px;
            }

            .header-restart {
                font-size: 11px;
                min-height: 36px;
                min-width: 78px;
                padding: 8px 10px;
            }
        }

        #board {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            gap: 8px;
            padding: 20px 5px;
            transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .column {
            display: flex;
            flex-direction: column;
            width: var(--card-w);
            max-width: var(--max-w);
            min-height: 120px;
            position: relative;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 6px;
        }

        .card {
            width: var(--card-w);
            height: var(--card-h);
            max-width: var(--max-w);
            max-height: var(--max-h);
            background: white;
            border-radius: 6px;
            color: black;
            position: relative;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.5);
            transition: transform 0.25s cubic-bezier(0.18, 0.89, 0.32, 1.28);
            display: flex;
            flex-direction: column;
            padding: 6px;
            box-sizing: border-box;
            border: 1px solid #ccc;
            margin-bottom: var(--fixed-gap);
        }

        @media (min-width: 450px) {
            .card {
                margin-bottom: -85px;
            }
        }

        .card:last-child {
            margin-bottom: 0;
        }

        .card.red {
            color: #d32f2f;
        }

        .card.is-fading {
            opacity: 0 !important;
            visibility: hidden;
        }

        .card.selected {
            transform: translateX(40%) rotate(3deg);
            z-index: 500 !important;
            outline: 3px solid var(--gold);
            filter: brightness(1.1);
        }

        .card.invalid-flash {
            animation: invalid-shake 0.36s ease-in-out 2;
            outline: 3px solid #ff3b30 !important;
            box-shadow: 0 0 0 2px rgba(255, 59, 48, 0.28), 0 0 16px rgba(255, 59, 48, 0.5);
        }

        @keyframes invalid-shake {

            0%,
            100% {
                transform: translateX(0);
            }

            25% {
                transform: translateX(-4px);
            }

            50% {
                transform: translateX(4px);
            }

            75% {
                transform: translateX(-3px);
            }
        }

        /* --- ÁâπÊïàÂ±§ --- */
        #fx-layer {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 9999;
        }

        .column-beam {
            position: absolute;
            width: 100%;
            height: 200vh;
            top: -50vh;
            background: linear-gradient(to right, transparent, rgba(255, 255, 255, 0.8), transparent);
            box-shadow: 0 0 30px white;
            animation: beam-out 0.8s ease-out forwards;
        }

        @keyframes beam-out {
            0% {
                scaleX(0);
                opacity: 0;
            }

            20% {
                scaleX(1.5);
                opacity: 1;
            }

            100% {
                scaleX(0);
                opacity: 0;
            }
        }

        .column-clear-text {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
            font-size: 1rem;
            color: #fff;
            text-shadow: 0 0 10px var(--gold);
            background: rgba(0, 0, 0, 0.6);
            padding: 5px 10px;
            border-radius: 5px;
            animation: text-float-up 1.2s ease-out forwards;
        }

        @keyframes text-float-up {
            0% {
                transform: translate(-50%, 0);
                opacity: 0;
            }

            20% {
                opacity: 1;
            }

            100% {
                transform: translate(-50%, -120px);
                opacity: 0;
            }
        }

        .combo-text {
            position: fixed;
            top: 45%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3.2rem;
            color: #fff;
            text-align: center;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.8), 0 0 20px rgba(255, 165, 0, 0.6);
            z-index: 10000;
            animation: combo-fancy 1.5s cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
        }

        @keyframes combo-fancy {
            0% {
                scale: 0.5;
                opacity: 0;
            }

            15% {
                scale: 1.2;
                opacity: 1;
            }

            75% {
                opacity: 1;
            }

            100% {
                transform: translate(-50%, -100%);
                opacity: 0;
            }
        }

        .lucky-three-win {
            animation: win-glow 1s infinite alternate;
            z-index: 1000 !important;
        }

        @keyframes win-glow {
            from {
                transform: scale(1.2);
                box-shadow: 0 0 20px var(--gold);
            }

            to {
                transform: scale(1.4) rotate(10deg);
                box-shadow: 0 0 50px white, 0 0 100px var(--gold);
            }
        }

        .particle {
            position: absolute;
            width: 6px;
            height: 6px;
            background: var(--gold);
            animation: p-fly 0.8s forwards;
        }

        @keyframes p-fly {
            0% {
                transform: translate(0, 0);
                opacity: 1;
            }

            100% {
                transform: translate(var(--tx), var(--ty));
                opacity: 0;
            }
        }

        /* Footer */
        #footer {
            background: rgba(0, 0, 0, 0.95);
            padding: 15px 10px calc(15px + env(safe-area-inset-bottom));
            display: flex;
            justify-content: space-around;
            align-items: center;
            border-top: 1px solid var(--gold);
        }

        .pile {
            width: 55px;
            height: 75px;
            border-radius: 5px;
            border: 1px solid white;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        #deck-pile {
            background: #1e88e5;
            box-shadow: 3px 3px 0 #0d47a1;
            cursor: pointer;
            font-size: 26px;
        }

        #discard-pile {
            background: rgba(255, 255, 255, 0.05);
            border: 1px dashed var(--gold);
        }

        .has-cards {
            background: white !important;
            color: black;
            border: 1px solid #999 !important;
        }

        .btn-main {
            background: #2e7d32;
            color: white;
            border: none;
            padding: 14px 28px;
            border-radius: 50px;
            font-weight: bold;
            box-shadow: 0 4px #000;
            cursor: pointer;
        }

        #btn-undo {
            background: #455a64;
            width: 50px;
            height: 50px;
            padding: 0;
            border-radius: 50%;
            box-shadow: 0 4px #263238;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #btn-undo svg {
            width: 24px;
            height: 24px;
            fill: white;
        }

        #btn-undo:disabled {
            opacity: 0.2;
            box-shadow: none;
            cursor: not-allowed;
        }

        .btn-main:active {
            transform: translateY(2px);
            box-shadow: 0 2px #1b5e20;
        }

        .flying {
            position: fixed;
            z-index: 9999;
            pointer-events: none;
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .card.face-down {
            background: linear-gradient(135deg, #0d47a1 0%, #1565c0 45%, #1e88e5 100%);
            border: 1px solid #e3f2fd;
            color: transparent;
            overflow: hidden;
        }

        .card.face-down::before {
            content: '';
            position: absolute;
            inset: 6px;
            border-radius: 4px;
            border: 2px solid rgba(255, 255, 255, 0.75);
            background:
                radial-gradient(circle at 25% 25%, rgba(255, 255, 255, 0.35) 0 2px, transparent 3px),
                radial-gradient(circle at 75% 75%, rgba(255, 255, 255, 0.35) 0 2px, transparent 3px),
                repeating-linear-gradient(45deg, rgba(255, 255, 255, 0.16) 0 6px, rgba(255, 255, 255, 0.05) 6px 12px);
        }

        .card.face-down::after {
            content: 'LUCKY 3';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.62rem;
            font-weight: 900;
            letter-spacing: 1px;
            color: rgba(255, 255, 255, 0.9);
        }

        .flying.mii-peek {
            animation: mii-peek-rise 0.28s ease-out forwards, mii-peek-shake 0.58s ease-in-out 0.3s 2;
            filter: drop-shadow(0 0 14px rgba(255, 215, 0, 0.9));
        }

        @keyframes mii-peek-rise {
            from {
                transform: translateY(0) scale(1);
            }

            to {
                transform: translateY(-12px) scale(1.07) rotate(-2deg);
            }
        }

        @keyframes mii-peek-shake {

            0%,
            100% {
                transform: translateY(-12px) scale(1.07) rotate(-2deg);
            }

            50% {
                transform: translateY(-9px) scale(1.11) rotate(2deg);
            }
        }

        .mii-text {
            position: absolute;
            top: -28px;
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
            font-size: 0.82rem;
            font-weight: 900;
            letter-spacing: 0.5px;
            color: #fff;
            background: rgba(16, 18, 20, 0.88);
            border: 1px solid rgba(255, 255, 255, 0.4);
            border-radius: 999px;
            padding: 4px 10px;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
            animation: mii-text-pop 1.4s ease-out forwards;
            z-index: 1003;
        }

        .mii-text.is-hot {
            color: #fff9cf;
            border-color: rgba(255, 215, 0, 0.85);
            box-shadow: 0 0 14px rgba(255, 215, 0, 0.55);
        }

        @keyframes mii-text-pop {
            0% {
                transform: translate(-50%, 8px) scale(0.9);
                opacity: 0;
            }

            18% {
                transform: translate(-50%, 0) scale(1.05);
                opacity: 1;
            }

            70% {
                transform: translate(-50%, -2px) scale(1.02);
                opacity: 1;
            }

            100% {
                transform: translate(-50%, -14px) scale(1);
                opacity: 0;
            }
        }

        .big-msg {
            position: fixed;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            color: var(--gold);
            text-align: center;
            z-index: 10001;
        }

        .win-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.72);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10002;
            padding: 20px;
        }

        .win-panel {
            width: min(420px, 92vw);
            background: linear-gradient(180deg, #123a1f, #0a2414);
            border: 2px solid var(--gold);
            border-radius: 14px;
            box-shadow: 0 18px 40px rgba(0, 0, 0, 0.55);
            padding: 20px 18px;
            text-align: center;
        }

        .win-title {
            margin: 0;
            color: var(--gold);
            font-size: 1.8rem;
            letter-spacing: 1px;
        }

        .win-subtitle {
            margin: 8px 0 14px;
            font-size: 0.95rem;
            opacity: 0.9;
        }

        .win-stats {
            text-align: left;
            background: rgba(255, 255, 255, 0.07);
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 14px;
        }

        .win-stat-row {
            display: flex;
            justify-content: space-between;
            font-size: 1rem;
            padding: 6px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.14);
        }

        .win-stat-row:last-child {
            border-bottom: none;
        }

        .win-play-again {
            width: 100%;
            border: none;
            border-radius: 12px;
            background: var(--gold);
            color: #1b1b1b;
            font-weight: 900;
            font-size: 1.05rem;
            padding: 12px 14px;
            cursor: pointer;
            min-height: 46px;
        }

        .win-best {
            margin: 0 0 12px;
            padding: 10px;
            border-radius: 10px;
            font-size: 0.95rem;
            background: rgba(255, 215, 0, 0.18);
            border: 1px solid rgba(255, 215, 0, 0.45);
            color: #fff8cc;
        }

        .deadlock-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.78);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10003;
            padding: 20px;
        }

        .deadlock-panel {
            width: min(430px, 92vw);
            background: linear-gradient(180deg, #3a1111, #240a0a);
            border: 2px solid #ff6b6b;
            border-radius: 14px;
            box-shadow: 0 18px 40px rgba(0, 0, 0, 0.55);
            padding: 18px;
            text-align: center;
        }

        .deadlock-title {
            margin: 0;
            color: #ffd2d2;
            font-size: 1.35rem;
            letter-spacing: 0.5px;
        }

        .deadlock-text {
            margin: 10px 0 14px;
            font-size: 0.96rem;
            line-height: 1.5;
            color: #ffe6e6;
        }

        .deadlock-actions {
            display: flex;
            gap: 10px;
        }

        .deadlock-btn {
            flex: 1;
            border: none;
            border-radius: 10px;
            min-height: 44px;
            font-weight: 800;
            cursor: pointer;
            font-size: 0.95rem;
        }

        .deadlock-btn.undo {
            background: #78909c;
            color: #102027;
        }

        .deadlock-btn.new {
            background: #ffd54f;
            color: #3e2723;
        }

        .deadlock-btn:disabled {
            opacity: 0.45;
            cursor: not-allowed;
        }
    </style>
</head>

<body>

    <div id="header">
        <div class="header-stat">DECK: <b id="deck-num">40</b></div>
        <div class="header-title">LUCKY 3</div>
        <div class="header-controls">
            <div id="timer" class="timer-pill">00:00</div>
            <button type="button" class="header-restart" onclick="resetGame()">RESTART</button>
        </div>
    </div>

    <div id="board"></div>
    <div id="fx-layer"></div>

    <div id="footer">
        <!-- ÁôºÁâå -->
        <div style="display: flex; flex-direction: column; align-items: center;">
            <div class="pile" id="deck-pile" onclick="dealOneCard()">üÇ†</div>
            <div style="font-size: 10px; color: var(--gold); margin-top: 5px;">DEAL</div>
        </div>

        <!-- ‰∏≠ÈñìÊåâÈàï -->
        <div style="display: flex; align-items: center; gap: 15px;">
            <button id="btn-undo" class="btn-main" onclick="undo()" disabled aria-label="Undo">
                <svg viewBox="0 0 24 24">
                    <path
                        d="M12.5 8c-2.65 0-5.05 1-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8z" />
                </svg>
            </button>
            <button id="btn-clear" class="btn-main" onclick="attemptClear()">CLEAR</button>
        </div>

        <!-- ÂõûÊî∂ -->
        <div style="text-align: center;">
            <div class="pile" id="discard-pile"></div>
            <div style="font-size: 10px; color: var(--gold); margin-top: 5px;">RECYCLE</div>
        </div>
    </div>

    <script>
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('./sw.js').catch(() => { });
        }

        const suits = ['‚ô†', '‚ô•', '‚ô¶', '‚ô£'], ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10'];
        const GAME_STATE_KEY = 'lucky3-current-game';
        let deck = [], slots = [], discardPile = [], clearedGroups = [];
        let selected = [], nextSlotIndex = 0, isBusy = false, historyStack = [], combo = 0, lastCleared = null, startTime = Date.now();
        let winInterval = null, moveCount = 0, maxCombo = 0, hasWon = false, deadlockShown = false;

        function shuffleInPlace(arr) {
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        // --- ÂàùÂßãÂåñËàáÈáçÁΩÆ ---
        function init(forceNew = false) {
            // Âº∑Âà∂Ëß£ÈéñÁãÄÊÖã
            isBusy = false;

            // Ê∏ÖÈô§ UI
            const fxLayer = document.getElementById('fx-layer');
            if (fxLayer) fxLayer.innerHTML = '';
            const bigMsg = document.querySelector('.big-msg');
            if (bigMsg) bigMsg.remove();
            const winOverlay = document.getElementById('win-overlay');
            if (winOverlay) winOverlay.remove();
            const deadlockOverlay = document.getElementById('deadlock-overlay');
            if (deadlockOverlay) deadlockOverlay.remove();
            if (winInterval) clearInterval(winInterval);

            if (!forceNew && loadGameState()) {
                document.getElementById('btn-undo').disabled = historyStack.length === 0;
                render();
                updateDiscard();
                if (!hasWon) checkDeadlock();
                return;
            }

            // ÈáçÁΩÆË≥áÊñô
            deck = [];
            discardPile = [];
            clearedGroups = [];
            const fixedBottomSuit = suits[Math.floor(Math.random() * suits.length)];
            const fixedBottomCard = { rank: '3', suit: fixedBottomSuit, val: 3, color: fixedBottomSuit === '‚ô•' || fixedBottomSuit === '‚ô¶' ? 'red' : 'black' };
            const topDeck = [];
            suits.forEach(s => ranks.forEach(r => {
                if (r === '3' && s === fixedBottomSuit) return;
                topDeck.push({ rank: r, suit: s, val: r === 'A' ? 1 : parseInt(r), color: s === '‚ô•' || s === '‚ô¶' ? 'red' : 'black' });
            }));
            shuffleInPlace(topDeck);
            // pop() ÊúÉÂæûÂ∞æÁ´ØÊäΩÁâåÔºåËÆìÂ∫ïÁâåÂõ∫ÂÆöÂú® index 0ÔºåÂèØÁ¢∫‰øùÂÆÉÊúÄÂæåÊâçË¢´ÊäΩÂà∞„ÄÇ
            deck = [fixedBottomCard, ...topDeck];

            slots = [
                { id: 0, cards: [], active: true },
                { id: 1, cards: [], active: true },
                { id: 2, cards: [], active: true },
                { id: 3, cards: [], active: true }
            ];

            selected = [];
            nextSlotIndex = 0;
            historyStack = [];
            combo = 0;
            lastCleared = null;
            startTime = Date.now();
            moveCount = 0;
            maxCombo = 0;
            hasWon = false;
            deadlockShown = false;

            // ÈáçÊñ∞Ê∏≤Êüì
            document.getElementById('btn-undo').disabled = true;
            render();
            updateDiscard();
            saveGameState();
        }

        function resetGame() {
            if (confirm("Á¢∫ÂÆöË¶ÅÈáçÊñ∞ÈñãÂßãÂóéÔºüÊâÄÊúâÈÄ≤Â∫¶Â∞áÊúÉÈÅ∫Â§±„ÄÇ")) {
                init(true);
            }
        }

        // Ë®àÊôÇÂô® (Âè™ÈúÄÂú®È†ÅÈù¢Âä†ËºâÊôÇÂü∑Ë°å‰∏ÄÊ¨° setInterval)
        setInterval(() => {
            const sec = Math.floor((Date.now() - startTime) / 1000);
            const m = Math.floor(sec / 60).toString().padStart(2, '0');
            const s = (sec % 60).toString().padStart(2, '0');
            const timerEl = document.getElementById('timer');
            if (timerEl) timerEl.innerText = `${m}:${s}`;
        }, 1000);

        // --- Ê†∏ÂøÉÊ∏≤Êüì ---
        function render() {
            const board = document.getElementById('board');
            board.innerHTML = ''; // ÂæπÂ∫ïÊ∏ÖÁ©∫Áï∂Ââç DOM

            slots.filter(s => s.active).forEach(slot => {
                const col = document.createElement('div');
                col.className = 'column'; col.id = `col-${slot.id}`;
                slot.cards.forEach((card, idx) => {
                    const div = document.createElement('div');
                    const selObj = selected.find(s => s.slotId === slot.id && s.idx === idx);
                    div.className = `card ${card.color} ${selObj ? 'selected' : ''}`;
                    div.style.zIndex = selObj ? 600 : idx;
                    div.innerHTML = `<div style="font-weight:bold">${card.rank}</div><div style="align-self:center; font-size:1.6rem">${card.suit}</div>`;
                    div.onclick = () => {
                        if (isBusy) return;
                        const sIdx = selected.findIndex(s => s.slotId === slot.id && s.idx === idx);
                        if (sIdx > -1) selected.splice(sIdx, 1);
                        else {
                            if (selected.length > 0 && selected[0].slotId !== slot.id) selected = [];
                            if (selected.length < 3) selected.push({ slotId: slot.id, idx });
                        }
                        render();
                    };
                    col.appendChild(div);
                });
                board.appendChild(col);
            });
            document.getElementById('deck-num').innerText = deck.length;
        }

        // --- ÁâπÊïàÈÇèËºØ ---
        function showColumnClearFX(slotId) {
            const colEl = document.getElementById(`col-${slotId}`);
            if (!colEl) return;
            triggerHaptic([80, 50, 80]);
            const beam = document.createElement('div'); beam.className = 'column-beam';
            colEl.appendChild(beam);
            const text = document.createElement('div'); text.className = 'column-clear-text';
            text.innerText = 'COLUMN CLEAR!'; colEl.appendChild(text);
            const rect = colEl.getBoundingClientRect();
            for (let i = 0; i < 15; i++) spawnP(rect.left + rect.width / 2, rect.top + rect.height / 2);
            setTimeout(() => { if (beam.parentNode) beam.remove(); if (text.parentNode) text.remove(); }, 1200);
        }

        function showMiiFX(colEl, isHot) {
            if (!colEl) return;
            const existing = colEl.querySelector('.mii-text');
            if (existing) existing.remove();

            const text = document.createElement('div');
            text.className = `mii-text ${isHot ? 'is-hot' : ''}`;
            text.innerText = isHot ? 'Âí™ÁâåÔºÅÊúâÊ©üÊúÉÊï¥ÂàóÊ∏ÖÁ©∫' : 'Âí™Áâå‰∏≠...';
            colEl.appendChild(text);
            triggerHaptic(isHot ? [30, 35, 60] : [25, 30, 25]);

            setTimeout(() => {
                if (text.parentNode) text.remove();
            }, 900);
        }

        // --- ÁôºÁâåËàáÊ∂àÈô§ ---
        async function dealOneCard() {
            if (isBusy) return;

            // Â¶ÇÊûúÁâåÂ∫´Á©∫‰∫ÜÔºå‰ΩÜÂõûÊî∂ÂçÄÊúâÁâåÔºåÂâáÈÄ≤Ë°åÂõûÊî∂
            if (deck.length === 0 && clearedGroups.length > 0) {
                recycleDeck();
                return;
            }

            if (deck.length === 0) {
                checkDeadlock();
                return;
            }

            // DealÊôÇÂèñÊ∂àÈÅ∏Âèñ
            if (selected.length > 0) {
                selected = [];
                render();
            }

            const avail = slots.find((s, i) => slots[(nextSlotIndex + i) % 4].active);
            if (!avail) return;
            isBusy = true; combo = 0;
            const target = slots[(nextSlotIndex + slots.indexOf(avail)) % 4];
            const prevIdx = nextSlotIndex;
            nextSlotIndex = (slots.indexOf(target) + 1) % 4;

            historyStack.push({ type: 'deal', slotId: target.id, prevIdx });
            document.getElementById('btn-undo').disabled = false;
            moveCount++;

            const card = deck.pop();
            const isMiiMoment = target.cards.length === 2;
            const miiSum = isMiiMoment ? target.cards.reduce((acc, c) => acc + c.val, 0) + card.val : 0;
            const isHotMii = isMiiMoment && [9, 19, 29].includes(miiSum);
            const fly = createFly(card, document.getElementById('deck-pile').getBoundingClientRect(), { hidden: isMiiMoment });
            render();
            const colEl = document.getElementById(`col-${target.id}`);
            const rect = colEl.getBoundingClientRect();
            const offset = (target.cards.length) * (window.innerWidth > 450 ? 30 : window.innerWidth * 0.08);

            requestAnimationFrame(() => {
                fly.style.left = rect.left + 'px'; fly.style.top = (rect.top + offset) + 'px';
            });

            if (isMiiMoment) {
                setTimeout(() => {
                    revealFlyCard(fly, card);
                    fly.classList.add('mii-peek');
                    showMiiFX(colEl, isHotMii);
                }, 760);

                setTimeout(() => {
                    target.cards.push(card);
                    fly.remove();
                    render();
                    isBusy = false;
                    checkDeadlock();
                    saveGameState();
                }, 1720);
            } else {
                setTimeout(() => {
                    target.cards.push(card); fly.remove(); render(); isBusy = false; checkDeadlock(); saveGameState();
                }, 400);
            }
        }

        function recycleDeck() {
            if (isBusy || clearedGroups.length === 0) return;
            isBusy = true;

            // È°ØÁ§∫ÈáçÊñ∞Ê¥óÁâåÁöÑÊèêÁ§∫
            const msg = document.createElement('div');
            msg.className = 'combo-text';
            msg.style.color = 'var(--gold)';
            msg.innerHTML = "RECYCLING...";
            document.getElementById('fx-layer').appendChild(msg);

            setTimeout(() => {
                // ÊåâÊ∂àÈô§ÁµÑÈ†ÜÂ∫èÂõûÊî∂ÔºöÁ¨¨‰∏ÄÁµÑÊ∂àÈô§ÁöÑÁâåÂõûÂà∞ÁâåÂ†ÜÊúÄ‰∏äÊñπÔºàÊúÄÂÖàË¢´ÊäΩÂà∞Ôºâ
                deck = [];
                for (let i = clearedGroups.length - 1; i >= 0; i--) {
                    deck.push(...clearedGroups[i]);
                }
                discardPile = [];
                clearedGroups = [];
                lastCleared = null;

                msg.remove();
                render();
                updateDiscard();
                isBusy = false;
                triggerHaptic([50, 50, 50]);
                checkDeadlock();
                saveGameState();
            }, 1000);
        }

        async function attemptClear() {
            if (selected.length !== 3 || isBusy) return;
            const slotId = selected[0].slotId; const slot = slots.find(s => s.id === slotId);
            const currentCards = [...slot.cards]; const sum = selected.reduce((a, c) => a + currentCards[c.idx].val, 0);
            const sortedIndices = selected.map(s => s.idx).sort((a, b) => a - b);
            const len = currentCards.length;
            const isPos = JSON.stringify(sortedIndices) === JSON.stringify([len - 3, len - 2, len - 1]) ||
                JSON.stringify(sortedIndices) === JSON.stringify([0, len - 2, len - 1]) ||
                JSON.stringify(sortedIndices) === JSON.stringify([0, 1, len - 1]);

            if ([9, 19, 29].includes(sum) && isPos) {
                isBusy = true;
                const colEl = document.getElementById(`col-${slotId}`);
                sortedIndices.forEach(idx => colEl.children[idx].classList.add('is-fading'));
                const clearedObjects = sortedIndices.map(idx => ({ idx: idx, data: { ...currentCards[idx] } }));
                historyStack.push({ type: 'clear', slotId, cards: clearedObjects, prevLast: lastCleared, comboBefore: combo });
                document.getElementById('btn-undo').disabled = false;
                const destRect = document.getElementById('discard-pile').getBoundingClientRect();
                lastCleared = currentCards[sortedIndices[sortedIndices.length - 1]];

                sortedIndices.forEach(idx => {
                    const fly = createFly(currentCards[idx], colEl.children[idx].getBoundingClientRect());
                    requestAnimationFrame(() => {
                        fly.style.left = destRect.left + 'px'; fly.style.top = destRect.top + 'px';
                        fly.style.transform = 'scale(0.5) rotate(20deg)'; fly.style.opacity = '0';
                    });
                    setTimeout(() => fly.remove(), 550);
                });

                setTimeout(() => {
                    const recycled = sortedIndices.map(i => slot.cards[i]);
                    discardPile.push(...recycled); // Áî®ÊñºÁõÆÂâçÂõûÊî∂ÂçÄÈ°ØÁ§∫
                    clearedGroups.push([...recycled]); // ‰øùÁïôÊØè‰∏ÄÁµÑÊ∂àÈô§È†ÜÂ∫è‰æõÂõûÊî∂ÁâåÂ†Ü‰ΩøÁî®
                    sortedIndices.sort((a, b) => b - a).forEach(i => slot.cards.splice(i, 1));
                    combo++; selected = [];
                    maxCombo = Math.max(maxCombo, combo);
                    moveCount++;
                    let colCleared = false; if (slot.cards.length === 0) { colCleared = true; showColumnClearFX(slotId); }

                    setTimeout(() => {
                        if (colCleared) slot.active = false;
                        render(); updateDiscard(); showCombo(sum); checkLucky3(); isBusy = false;
                        if (!hasWon) checkDeadlock();
                        saveGameState();
                    }, colCleared ? 800 : 0);

                    if (navigator.vibrate) navigator.vibrate(sum === 29 ? [60, 40, 60] : 40);
                    if (sum === 29) spawnP(window.innerWidth / 2, window.innerHeight / 2);
                }, 400);
            } else {
                combo = 0; triggerHaptic(100);
                document.getElementById('btn-clear').style.background = '#c62828';
                setTimeout(() => document.getElementById('btn-clear').style.background = '', 300);

                const slotId = selected[0]?.slotId;
                const colEl = slotId != null ? document.getElementById(`col-${slotId}`) : null;
                selected.forEach(s => {
                    const cardEl = colEl?.children?.[s.idx];
                    if (cardEl) cardEl.classList.add('invalid-flash');
                });

                setTimeout(() => {
                    selected = [];
                    render();
                    checkDeadlock();
                    saveGameState();
                }, 760);
            }
        }

        function undo() {
            if (historyStack.length === 0 || isBusy) return;
            const last = historyStack.pop(); combo = last.comboBefore || 0;
            moveCount = Math.max(0, moveCount - 1);
            if (last.type === 'deal') {
                const s = slots.find(x => x.id === last.slotId); deck.push(s.cards.pop()); nextSlotIndex = last.prevIdx;
            } else {
                const s = slots.find(x => x.id === last.slotId); s.active = true;
                // ÂæûÂõûÊî∂Â†ÜÁßªÈô§ÊúÄÂæå‰∏âÂºµÁâå
                discardPile.splice(-3);
                clearedGroups.pop();
                last.cards.sort((a, b) => a.idx - b.idx).forEach(c => s.cards.splice(c.idx, 0, c.data));
                lastCleared = last.prevLast;
            }
            selected = []; render(); updateDiscard();
            if (historyStack.length === 0) document.getElementById('btn-undo').disabled = true;
            checkDeadlock();
            saveGameState();
        }

        function checkLucky3() {
            if (hasWon) return;
            const all = slots.flatMap(s => s.cards);
            if (all.length === 1 && all[0].val === 3) {
                hasWon = true;
                setTimeout(() => {
                    const card = document.querySelector('.card'); if (card) card.classList.add('lucky-three-win');
                    showWinPanel();
                    winInterval = setInterval(() => spawnP(Math.random() * window.innerWidth, Math.random() * window.innerHeight), 300);
                }, 500);
            }
        }

        function showCombo(s) {
            if (combo < 2) return;
            const layer = document.getElementById('fx-layer');
            const comboDiv = document.createElement('div'); comboDiv.className = 'combo-text';
            comboDiv.innerHTML = `${combo} COMBO!<br><span style="font-size:1.2rem;color:var(--gold)">+${s} PTS</span>`;
            layer.appendChild(comboDiv); setTimeout(() => comboDiv.remove(), 1500);
        }

        function triggerHaptic(ms) { if (navigator.vibrate) navigator.vibrate(ms); }

        function spawnP(x, y) {
            for (let i = 0; i < 15; i++) {
                const p = document.createElement('div'); p.className = 'particle'; p.style.left = x + 'px'; p.style.top = y + 'px';
                p.style.setProperty('--tx', (Math.random() - 0.5) * 400 + 'px'); p.style.setProperty('--ty', (Math.random() - 0.5) * 400 + 'px');
                document.getElementById('fx-layer').appendChild(p); setTimeout(() => p.remove(), 800);
            }
        }

        function setFlyFace(f, data) {
            f.classList.remove('face-down');
            f.classList.toggle('red', data.color === 'red');
            f.innerHTML = `<div style="font-weight:bold">${data.rank}</div><div style="align-self:center; font-size:1.6rem">${data.suit}</div>`;
        }

        function revealFlyCard(f, data) {
            setFlyFace(f, data);
        }

        function createFly(data, rect, options = {}) {
            const f = document.createElement('div');
            f.className = 'card flying';
            if (options.hidden) {
                f.classList.add('face-down');
                f.innerHTML = '';
            } else {
                setFlyFace(f, data);
            }
            f.style.left = rect.left + 'px';
            f.style.top = rect.top + 'px';
            document.body.appendChild(f);
            return f;
        }

        function updateDiscard() {
            const p = document.getElementById('discard-pile');
            if (lastCleared) {
                p.innerHTML = `<div style="font-size:10px; position:absolute; top:2px; left:4px;">${lastCleared.rank}</div><div style="font-size:14px;">${lastCleared.suit}</div>`;
                p.className = `pile has-cards ${lastCleared.color}`;
                p.style.boxShadow = `3px 3px 0 rgba(255,215,0,0.4)`;
            } else { p.className = 'pile'; p.innerHTML = ''; p.style.boxShadow = 'none'; }
        }

        function formatTime(totalSec) {
            const m = Math.floor(totalSec / 60).toString().padStart(2, '0');
            const s = (totalSec % 60).toString().padStart(2, '0');
            return `${m}:${s}`;
        }

        function loadBestStats() {
            try {
                const raw = localStorage.getItem('lucky3-best-stats');
                if (!raw) return { fastestTimeSec: null, fewestMoves: null, highestCombo: 0 };
                const parsed = JSON.parse(raw);
                return {
                    fastestTimeSec: Number.isFinite(parsed.fastestTimeSec) ? parsed.fastestTimeSec : null,
                    fewestMoves: Number.isFinite(parsed.fewestMoves) ? parsed.fewestMoves : null,
                    highestCombo: Number.isFinite(parsed.highestCombo) ? parsed.highestCombo : 0
                };
            } catch (_) {
                return { fastestTimeSec: null, fewestMoves: null, highestCombo: 0 };
            }
        }

        function saveBestStats(stats) {
            try {
                localStorage.setItem('lucky3-best-stats', JSON.stringify(stats));
            } catch (_) { }
        }

        function updateBestStats(current) {
            const best = loadBestStats();
            const isNewFastest = best.fastestTimeSec == null || current.elapsedSec < best.fastestTimeSec;
            const isNewFewestMoves = best.fewestMoves == null || current.moveCount < best.fewestMoves;
            const isNewHighestCombo = current.maxCombo > (best.highestCombo || 0);

            const nextBest = {
                fastestTimeSec: isNewFastest ? current.elapsedSec : best.fastestTimeSec,
                fewestMoves: isNewFewestMoves ? current.moveCount : best.fewestMoves,
                highestCombo: isNewHighestCombo ? current.maxCombo : best.highestCombo
            };
            saveBestStats(nextBest);

            return {
                best: nextBest,
                flags: { isNewFastest, isNewFewestMoves, isNewHighestCombo }
            };
        }

        function buildBestMessage(result) {
            const flags = result.flags;
            if (flags.isNewFastest) return `üéâ Êú¨Â±ÄÊúÄ‰Ω≥ÊàêÁ∏æÔºöÁ†¥Ëá™Â∑±ÊúÄÂø´ÊôÇÈñìÔºà${formatTime(result.best.fastestTimeSec)}Ôºâ`;
            if (flags.isNewFewestMoves) return `‚ú® Êú¨Â±ÄÊúÄ‰Ω≥ÊàêÁ∏æÔºöÂà∑Êñ∞ÊúÄÂ∞ëÊ≠•Êï∏Ôºà${result.best.fewestMoves} Ê≠•Ôºâ`;
            if (flags.isNewHighestCombo) return `üî• Êú¨Â±ÄÊúÄ‰Ω≥ÊàêÁ∏æÔºöÂà∑Êñ∞ÊúÄÈ´òÈÄ£ÊìäÔºà${result.best.highestCombo}Ôºâ`;
            return `ÊúÄ‰Ω≥Á¥ÄÈåÑÔºöÊúÄÂø´ ${formatTime(result.best.fastestTimeSec || 0)} / ÊúÄÂ∞ë ${result.best.fewestMoves || 0} Ê≠•`;
        }

        function showWinPanel() {
            const old = document.getElementById('win-overlay');
            if (old) old.remove();

            const elapsedSec = Math.floor((Date.now() - startTime) / 1000);
            const bestResult = updateBestStats({ elapsedSec, moveCount, maxCombo });
            const bestMessage = buildBestMessage(bestResult);
            const overlay = document.createElement('div');
            overlay.className = 'win-overlay';
            overlay.id = 'win-overlay';
            overlay.innerHTML = `
                <div class="win-panel">
                    <h2 class="win-title">LUCKY 3 JACKPOT</h2>
                    <p class="win-subtitle">Ë∂ÖËÆöÔºÅ‰Ω†ÊääÁâåÂ±ÄÊî∂‰πæÊ∑®‰∫Ü ‚ú®</p>
                    <div class="win-stats">
                        <div class="win-stat-row"><span>Áî®ÊôÇ</span><strong>${formatTime(elapsedSec)}</strong></div>
                        <div class="win-stat-row"><span>Á∏ΩÊ≠•Êï∏</span><strong>${moveCount}</strong></div>
                        <div class="win-stat-row"><span>ÊúÄÈ´òÈÄ£Êìä</span><strong>${maxCombo}</strong></div>
                    </div>
                    <p class="win-best">${bestMessage}</p>
                    <button type="button" class="win-play-again" onclick="playAgain()">ÂÜç‰æÜ‰∏ÄÂ±Ä</button>
                </div>
            `;
            document.body.appendChild(overlay);
        }

        function playAgain() {
            init(true);
        }

        function hasLegalClearInSlot(cards) {
            const len = cards.length;
            if (len < 3) return false;

            const candidates = [
                [len - 3, len - 2, len - 1],
                [0, len - 2, len - 1],
                [0, 1, len - 1]
            ];
            const uniqueCandidates = [...new Set(candidates.map(c => JSON.stringify(c)))].map(x => JSON.parse(x));

            return uniqueCandidates.some(indices => {
                if (indices.some(i => i < 0 || i >= len)) return false;
                const sum = indices.reduce((acc, i) => acc + cards[i].val, 0);
                return [9, 19, 29].includes(sum);
            });
        }

        function hasAnyLegalClear() {
            return slots.some(s => s.active && hasLegalClearInSlot(s.cards));
        }

        function hideDeadlockOverlay() {
            const overlay = document.getElementById('deadlock-overlay');
            if (overlay) overlay.remove();
            deadlockShown = false;
        }

        function showDeadlockOverlay() {
            if (deadlockShown) return;
            const old = document.getElementById('deadlock-overlay');
            if (old) old.remove();

            const canUndo = historyStack.length > 0;
            const overlay = document.createElement('div');
            overlay.className = 'deadlock-overlay';
            overlay.id = 'deadlock-overlay';
            overlay.innerHTML = `
                <div class="deadlock-panel">
                    <h3 class="deadlock-title">Âç°‰Ωè‰∫ÜÔºÅÁõÆÂâçÁÑ°ÂêàÊ≥ïÊ∂àÈô§</h3>
                    <p class="deadlock-text">ÁâåÂ∫´Â∑≤Á©∫Ôºå‰∏îÂ†¥‰∏äÊ≤íÊúâÂèØÊ∂àÈô§ÁöÑ 9 / 19 / 29 ÁµÑÂêà„ÄÇ‰Ω†ÊÉ≥Ë¶ÅÂÄíËΩâ‰∏ÄÊ≠•ÔºåÈÇÑÊòØÁõ¥Êé•ÈñãÊñ∞Â±ÄÔºü</p>
                    <div class="deadlock-actions">
                        <button type="button" class="deadlock-btn undo" onclick="resolveDeadlock('undo')" ${canUndo ? '' : 'disabled'}>ÂÄíËΩâ‰∏ÄÊ≠•</button>
                        <button type="button" class="deadlock-btn new" onclick="resolveDeadlock('new')">ÈñãÊñ∞Â±Ä</button>
                    </div>
                </div>
            `;
            document.body.appendChild(overlay);
            deadlockShown = true;
            triggerHaptic([80, 50, 80]);
        }

        function resolveDeadlock(action) {
            hideDeadlockOverlay();
            if (action === 'undo') {
                undo();
                return;
            }
            if (action === 'new') {
                init(true);
            }
        }

        function checkDeadlock() {
            if (hasWon || isBusy) return false;

            if (deck.length > 0 || clearedGroups.length > 0) {
                hideDeadlockOverlay();
                return false;
            }

            if (hasAnyLegalClear()) {
                hideDeadlockOverlay();
                return false;
            }

            showDeadlockOverlay();
            return true;
        }

        function buildSavePayload() {
            const elapsedSec = Math.floor((Date.now() - startTime) / 1000);
            return {
                deck,
                slots,
                discardPile,
                clearedGroups,
                nextSlotIndex,
                historyStack,
                combo,
                lastCleared,
                moveCount,
                maxCombo,
                hasWon,
                elapsedSec
            };
        }

        function isValidCard(card) {
            return card && typeof card.rank === 'string' && typeof card.suit === 'string' && Number.isFinite(card.val) &&
                (card.color === 'red' || card.color === 'black');
        }

        function isValidSlot(slot) {
            return slot && Number.isInteger(slot.id) && Array.isArray(slot.cards) && typeof slot.active === 'boolean' &&
                slot.cards.every(isValidCard);
        }

        function saveGameState() {
            try {
                localStorage.setItem(GAME_STATE_KEY, JSON.stringify(buildSavePayload()));
            } catch (_) { }
        }

        function loadGameState() {
            try {
                const raw = localStorage.getItem(GAME_STATE_KEY);
                if (!raw) return false;
                const parsed = JSON.parse(raw);

                if (!Array.isArray(parsed.deck) || !Array.isArray(parsed.slots) || !Array.isArray(parsed.discardPile) || !Array.isArray(parsed.clearedGroups)) return false;
                if (!parsed.deck.every(isValidCard) || !parsed.discardPile.every(isValidCard)) return false;
                if (!parsed.slots.every(isValidSlot)) return false;
                if (!parsed.clearedGroups.every(group => Array.isArray(group) && group.every(isValidCard))) return false;

                deck = parsed.deck;
                slots = parsed.slots;
                discardPile = parsed.discardPile;
                clearedGroups = parsed.clearedGroups;
                nextSlotIndex = Number.isInteger(parsed.nextSlotIndex) ? parsed.nextSlotIndex : 0;
                historyStack = Array.isArray(parsed.historyStack) ? parsed.historyStack : [];
                combo = Number.isInteger(parsed.combo) ? parsed.combo : 0;
                lastCleared = parsed.lastCleared && isValidCard(parsed.lastCleared) ? parsed.lastCleared : null;
                moveCount = Number.isInteger(parsed.moveCount) ? parsed.moveCount : 0;
                maxCombo = Number.isInteger(parsed.maxCombo) ? parsed.maxCombo : 0;
                hasWon = Boolean(parsed.hasWon);
                deadlockShown = false;
                selected = [];
                const elapsedSec = Number.isFinite(parsed.elapsedSec) ? Math.max(0, parsed.elapsedSec) : 0;
                startTime = Date.now() - elapsedSec * 1000;
                return true;
            } catch (_) {
                return false;
            }
        }

        window.addEventListener('beforeunload', saveGameState);
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) saveGameState();
        });

        init();
    </script>
</body>

</html>
